{
  BlockingQueue buffer;
  if (maxBufferSize > 0 && maxThreadsActive > 1) {
    buffer=new LinkedBlockingDeque(maxBufferSize);
  }
 else {
    buffer=new SynchronousQueue();
  }
  if (maxThreadsIdle > maxThreadsActive) {
    maxThreadsIdle=maxThreadsActive;
  }
  ThreadPoolExecutor pool=new ThreadPoolExecutor(maxThreadsIdle,maxThreadsActive,threadTTL,TimeUnit.MILLISECONDS,buffer);
  ThreadFactory tf=threadFactory;
  if (name != null) {
    tf=new NamedThreadFactory(name);
  }
  if (tf != null) {
    pool.setThreadFactory(tf);
  }
  if (rejectedExecutionHandler != null) {
    pool.setRejectedExecutionHandler(rejectedExecutionHandler);
  }
 else {
switch (poolExhaustPolicy) {
case WHEN_EXHAUSTED_DISCARD_OLDEST:
      pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardOldestPolicy());
    break;
case WHEN_EXHAUSTED_RUN:
  pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
break;
case WHEN_EXHAUSTED_ABORT:
pool.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());
break;
case WHEN_EXHAUSTED_DISCARD:
pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());
break;
case WHEN_EXHAUSTED_WAIT:
pool.setRejectedExecutionHandler(new WaitPolicy(threadWaitTimeout,TimeUnit.MILLISECONDS));
break;
default :
pool.setRejectedExecutionHandler(new WaitPolicy(threadWaitTimeout,TimeUnit.MILLISECONDS));
break;
}
}
return pool;
}
