{
  BlockingQueue buffer;
  if (getMaxBufferSize() > 0 && getMaxThreadsActive() > 1) {
    buffer=new LinkedBlockingDeque(getMaxBufferSize());
  }
 else {
    buffer=new SynchronousQueue();
  }
  ThreadPoolExecutor pool=new ThreadPoolExecutor(Math.max(getMaxThreadsIdle(),getMaxThreadsActive()),getMaxThreadsActive(),getThreadTTL(),TimeUnit.MILLISECONDS,buffer);
  ThreadFactory tf=threadFactory;
  if (name != null) {
    tf=new NamedThreadFactory(name);
  }
  if (tf != null) {
    pool.setThreadFactory(tf);
  }
  if (rejectedExecutionHandler != null) {
    pool.setRejectedExecutionHandler(rejectedExecutionHandler);
  }
 else {
switch (getPoolExhaustedAction()) {
case WHEN_EXHAUSTED_DISCARD_OLDEST:
      pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardOldestPolicy());
    break;
case WHEN_EXHAUSTED_RUN:
  pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
break;
case WHEN_EXHAUSTED_ABORT:
pool.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());
break;
case WHEN_EXHAUSTED_DISCARD:
pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());
break;
default :
pool.setRejectedExecutionHandler(new WaitPolicy(getThreadWaitTimeout(),TimeUnit.MILLISECONDS));
break;
}
}
return pool;
}
