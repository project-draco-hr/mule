{
  final SensingNullMessageProcessor sensingMessageProcessor=new SensingNullMessageProcessor();
  doAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocationOnMock) throws Throwable {
      ResponseCompletionCallback callback=(ResponseCompletionCallback)invocationOnMock.getArguments()[1];
      callback.responseSentWithFailure(mockException,mockMuleEvent);
      return null;
    }
  }
).when(mockTemplate).sendResponseToClient(any(MuleEvent.class),any(ResponseCompletionCallback.class));
  when(mockMuleEvent.isAllowNonBlocking()).thenReturn(true);
  when(mockTemplate.routeEvent(any(MuleEvent.class))).thenAnswer(new Answer<MuleEvent>(){
    @Override public MuleEvent answer(    InvocationOnMock invocation) throws Throwable {
      return sensingMessageProcessor.process((MuleEvent)invocation.getArguments()[0]);
    }
  }
);
  phase.runPhase(mockTemplate,mockContext,mockNotifier);
  sensingMessageProcessor.latch.await(LATCH_TIMEOUT,TimeUnit.MILLISECONDS);
  verify(notificationHelper).fireNotification(any(MessageSource.class),any(MuleEvent.class),isNull(String.class),any(FlowConstruct.class),eq(MESSAGE_RESPONSE));
  verify(notificationHelper,never()).fireNotification(any(MessageSource.class),any(MuleEvent.class),isNull(String.class),any(FlowConstruct.class),eq(MESSAGE_ERROR_RESPONSE));
}
