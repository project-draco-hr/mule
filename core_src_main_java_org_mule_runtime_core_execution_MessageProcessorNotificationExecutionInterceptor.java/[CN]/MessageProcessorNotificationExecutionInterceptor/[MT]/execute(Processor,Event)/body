{
  final ServerNotificationManager notificationManager=muleContext.getNotificationManager();
  final boolean fireNotification=event.isNotificationsEnabled();
  if (fireNotification) {
    fireNotification(notificationManager,flowConstruct,event,messageProcessor,null,MESSAGE_PROCESSOR_PRE_INVOKE);
  }
  Event eventToProcess=event;
  Event result=null;
  MessagingException exceptionThrown=null;
  boolean nonBlocking=event.isAllowNonBlocking() && event.getReplyToHandler() != null;
  boolean responseProcessing=messageProcessor instanceof InterceptingMessageProcessor || messageProcessor instanceof NonBlockingMessageProcessor;
  if (nonBlocking && responseProcessing) {
    final ReplyToHandler originalReplyToHandler=event.getReplyToHandler();
    eventToProcess=Event.builder(event).replyToHandler(new NonBlockingReplyToHandler(){
      @Override public Event processReplyTo(      Event result,      InternalMessage returnMessage,      Object replyTo) throws MuleException {
        if (fireNotification) {
          fireNotification(notificationManager,flowConstruct,result != null ? result : event,messageProcessor,null,MESSAGE_PROCESSOR_POST_INVOKE);
        }
        return originalReplyToHandler.processReplyTo(result,returnMessage,replyTo);
      }
      @Override public void processExceptionReplyTo(      MessagingException exception,      Object replyTo){
        if (fireNotification) {
          Event result=exception.getEvent();
          fireNotification(notificationManager,flowConstruct,result != null ? result : event,messageProcessor,null,MESSAGE_PROCESSOR_POST_INVOKE);
        }
        originalReplyToHandler.processExceptionReplyTo(exception,replyTo);
      }
    }
).build();
  }
  setCurrentEvent(eventToProcess);
  try {
    if (next == null) {
      result=messageProcessor.process(eventToProcess);
    }
 else {
      result=next.execute(messageProcessor,eventToProcess);
    }
  }
 catch (  MessagingException e) {
    exceptionThrown=e;
    throw e;
  }
catch (  MuleException e) {
    exceptionThrown=new MessagingException(event,e,messageProcessor);
    throw exceptionThrown;
  }
 finally {
    if (!NonBlockingVoidMuleEvent.getInstance().equals(result) && fireNotification) {
      fireNotification(notificationManager,flowConstruct,result != null ? result : event,messageProcessor,exceptionThrown,MESSAGE_PROCESSOR_POST_INVOKE);
    }
  }
  return result;
}
