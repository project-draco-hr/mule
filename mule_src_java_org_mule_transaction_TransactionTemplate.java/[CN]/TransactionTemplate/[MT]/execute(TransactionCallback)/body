{
  if (config == null) {
    return callback.doInTransaction();
  }
 else {
    byte action=config.getAction();
    UMOTransaction tx=TransactionCoordination.getInstance().getTransaction();
    if (action == UMOTransactionConfig.ACTION_NONE && tx != null) {
      throw new IllegalTransactionStateException(new Message(Messages.TX_AVAILABLE_BUT_ACTION_IS_X,"None"));
    }
 else     if (action == UMOTransactionConfig.ACTION_ALWAYS_BEGIN && tx != null) {
      throw new IllegalTransactionStateException(new Message(Messages.TX_AVAILABLE_BUT_ACTION_IS_X,"Always Begin"));
    }
 else     if (action == UMOTransactionConfig.ACTION_ALWAYS_JOIN && tx == null) {
      throw new IllegalTransactionStateException(new Message(Messages.TX_NOT_AVAILABLE_BUT_ACTION_IS_X,"Always Join"));
    }
    if (action == UMOTransactionConfig.ACTION_ALWAYS_BEGIN || action == UMOTransactionConfig.ACTION_BEGIN_OR_JOIN) {
      logger.debug("Beginning transaction");
      tx=config.getFactory().beginTransaction();
      logger.debug("Transaction successfully started");
    }
 else {
      tx=null;
    }
    try {
      Object result=callback.doInTransaction();
      if (tx != null) {
        if (tx.isRollbackOnly()) {
          logger.debug("Transaction is marked for rollback");
          tx.rollback();
        }
 else {
          logger.debug("Committing transaction");
          tx.commit();
        }
      }
      return result;
    }
 catch (    Exception e) {
      logger.info("Exception Caught in Transaction template.  Handing of to exception handler: " + exceptionListener);
      exceptionListener.exceptionThrown(e);
      if (tx != null) {
        if (tx.isRollbackOnly()) {
          logger.debug("Exception caught: rollback transaction",e);
          tx.rollback();
        }
 else {
          tx.commit();
        }
      }
      return null;
    }
catch (    Error e) {
      if (tx != null) {
        logger.info("Error caught: rollback transaction",e);
        tx.rollback();
      }
      throw e;
    }
  }
}
