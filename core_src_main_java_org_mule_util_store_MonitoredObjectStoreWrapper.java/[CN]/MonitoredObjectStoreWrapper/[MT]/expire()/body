{
  try {
    final long now=System.nanoTime();
    List<Serializable> keys=allKeys();
    int excess=(allKeys().size() - maxEntries);
    if (maxEntries > 0 && excess > 0) {
      PriorityQueue<StoredObject<T>> q=new PriorityQueue<StoredObject<T>>(excess,new Comparator<StoredObject<T>>(){
        @Override public int compare(        StoredObject<T> paramT1,        StoredObject<T> paramT2){
          return paramT2.timestamp.compareTo(paramT1.timestamp);
        }
      }
);
      long youngest=Long.MAX_VALUE;
      for (      Serializable key : keys) {
        StoredObject<T> obj=getStore().retrieve(key);
        if (TimeUnit.NANOSECONDS.toMillis(now - obj.getTimestamp()) >= entryTTL) {
          remove(key);
          excess--;
          if (excess > 0 && q.size() > excess) {
            q.poll();
            youngest=q.peek().timestamp;
          }
        }
 else {
          if (excess > 0 && (q.size() < excess || obj.timestamp < youngest)) {
            q.offer(obj);
            youngest=q.peek().timestamp;
          }
          if (excess > 0 && q.size() > excess) {
            q.poll();
            youngest=q.peek().timestamp;
          }
        }
      }
      for (int i=0; i < excess; i++) {
        Serializable key=q.poll().key;
        remove(key);
      }
    }
 else {
      for (      Serializable key : keys) {
        StoredObject<T> obj=getStore().retrieve(key);
        if (TimeUnit.NANOSECONDS.toMillis(now - obj.getTimestamp()) >= entryTTL) {
          remove(key);
        }
      }
    }
  }
 catch (  Exception e) {
    logger.warn("Running expirty on " + baseStore + " threw "+ e+ ":"+ e.getMessage());
  }
}
