{
  boolean exceptionSeen=false;
  boolean tooMany=false;
  AtomicInteger counter=null;
  String messageId=null;
  try {
    messageId=getIdForEvent(event);
  }
 catch (  TransformerException e) {
    logger.warn("The message cannot be processed because the digest could not be generated. Either make the payload serializable or use an expression.");
    return null;
  }
catch (  Exception ex) {
    exceptionSeen=true;
  }
  Lock lock=lockFactory.createLock(idrId + "-" + messageId);
  lock.lock();
  try {
    if (!exceptionSeen) {
      counter=findCounter(messageId);
      tooMany=counter != null && counter.get() > maxRedeliveryCount;
    }
    if (tooMany || exceptionSeen) {
      try {
        if (deadLetterQueue != null) {
          return deadLetterQueue.process(event);
        }
 else {
          throw new MessageRedeliveredException(messageId,counter.get(),maxRedeliveryCount,null,event,this);
        }
      }
 catch (      MessageRedeliveredException ex) {
        throw ex;
      }
catch (      Exception ex) {
        logger.info("Exception thrown from failed message processing for message " + messageId,ex);
      }
      return null;
    }
    try {
      MuleEvent returnEvent=processNext(event);
      counter=findCounter(messageId);
      if (counter != null) {
        resetCounter(messageId);
      }
      return returnEvent;
    }
 catch (    MuleException ex) {
      incrementCounter(messageId);
      throw ex;
    }
catch (    RuntimeException ex) {
      incrementCounter(messageId);
      throw ex;
    }
  }
  finally {
    lock.unlock();
  }
}
