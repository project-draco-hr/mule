{
  return new CollectionCorrelatorCallback(event.getMuleContext()){
    /** 
 * This method is invoked if the shouldAggregate method is called and returns
 * true. Once this method returns an aggregated message the event group is
 * removed from the router
 * @param events the event group for this request
 * @return an aggregated message
 * @throws org.mule.routing.AggregationException if the aggregation fails. in
 * this scenario the whole event group is removed and passed to the
 * exception handler for this componenet
 */
    @Override public MuleMessage aggregateEvents(    EventGroup events) throws AggregationException {
      MuleEvent[] collectedEvents=events.toArray();
      MuleEvent firstEvent=collectedEvents[0];
      Arrays.sort(collectedEvents,eventComparator);
      ByteArrayOutputStream baos=new ByteArrayOutputStream(DEFAULT_BUFFER_SIZE);
      try {
        for (Iterator iterator=IteratorUtils.arrayIterator(collectedEvents); iterator.hasNext(); ) {
          MuleEvent event=(MuleEvent)iterator.next();
          baos.write(event.getMessageAsBytes());
        }
        MuleMessage message;
        try {
          message=new DefaultMuleMessage(SerializationUtils.deserialize(baos.toByteArray()),firstEvent.getMessage(),muleContext);
        }
 catch (        SerializationException e) {
          message=new DefaultMuleMessage(baos.toByteArray(),firstEvent.getMessage(),muleContext);
        }
        message.setCorrelationGroupSize(-1);
        message.setCorrelationSequence(-1);
        return message;
      }
 catch (      Exception e) {
        throw new AggregationException(events,firstEvent.getEndpoint(),e);
      }
 finally {
        IOUtils.closeQuietly(baos);
      }
    }
  }
;
}
