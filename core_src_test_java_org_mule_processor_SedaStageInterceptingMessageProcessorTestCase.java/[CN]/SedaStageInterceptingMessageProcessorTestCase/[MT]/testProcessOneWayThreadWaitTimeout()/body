{
  final int threadTimeout=20;
  ThreadingProfile threadingProfile=new ChainedThreadingProfile(muleContext.getDefaultThreadingProfile());
  threadingProfile.setThreadWaitTimeout(threadTimeout);
  threadingProfile.setMaxThreadsActive(3);
  threadingProfile.setPoolExhaustedAction(ThreadingProfile.WHEN_EXHAUSTED_WAIT);
  threadingProfile.setMuleContext(muleContext);
  MessageProcessor mockListener=mock(MessageProcessor.class);
  when(mockListener.process((MuleEvent)any())).thenAnswer(new Answer<MuleEvent>(){
    public MuleEvent answer(    InvocationOnMock invocation) throws Throwable {
      Thread.sleep(threadTimeout * 2);
      return (MuleEvent)invocation.getArguments()[0];
    }
  }
);
  SedaStageInterceptingMessageProcessor sedaStageInterceptingMessageProcessor=new SedaStageInterceptingMessageProcessor("testProcessOneWayThreadWaitTimeout","testProcessOneWayThreadWaitTimeout",queueProfile,queueTimeout,threadingProfile,queueStatistics,muleContext);
  sedaStageInterceptingMessageProcessor.setListener(mockListener);
  sedaStageInterceptingMessageProcessor.initialise();
  sedaStageInterceptingMessageProcessor.start();
  MessagingExceptionHandler exceptionHandler=mock(MessagingExceptionHandler.class);
  Flow flow=mock(Flow.class);
  when(flow.getExceptionListener()).thenReturn(exceptionHandler);
  when(flow.getProcessingStrategy()).thenReturn(new AsynchronousProcessingStrategy());
  final MuleEvent event=getTestEvent(TEST_MESSAGE,flow,MessageExchangePattern.ONE_WAY);
  for (int i=0; i < 3; i++) {
    sedaStageInterceptingMessageProcessor.process(event);
  }
  ArgumentMatcher<MuleEvent> notSameEvent=new ArgumentMatcher<MuleEvent>(){
    @Override public boolean matches(    Object argument){
      return !argument.equals(event);
    }
  }
;
  verify(mockListener,timeout(RECEIVE_TIMEOUT).times(2)).process(argThat(notSameEvent));
  verify(exceptionHandler,timeout(RECEIVE_TIMEOUT).times(1)).handleException((Exception)any(),argThat(notSameEvent));
}
