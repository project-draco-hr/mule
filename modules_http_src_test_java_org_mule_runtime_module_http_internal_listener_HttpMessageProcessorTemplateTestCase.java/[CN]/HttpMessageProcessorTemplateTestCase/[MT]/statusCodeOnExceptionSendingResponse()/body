{
  Event testEvent=createMockEvent();
  HttpResponseReadyCallback responseReadyCallback=mock(HttpResponseReadyCallback.class);
  RuntimeException expected=new RuntimeException("Some exception");
  ArgumentCaptor<HttpResponse> httpResponseCaptor=ArgumentCaptor.forClass(HttpResponse.class);
  doThrow(expected).when(responseReadyCallback).responseReady(httpResponseCaptor.capture(),any(ResponseStatusCallback.class));
  HttpMessageProcessorTemplate httpMessageProcessorTemplate=new HttpMessageProcessorTemplate(testEvent,mock(Processor.class),responseReadyCallback,null,HttpResponseBuilder.emptyInstance(muleContext));
  ResponseCompletionCallback responseCompletionCallback=mock(ResponseCompletionCallback.class);
  try {
    httpMessageProcessorTemplate.sendResponseToClient(testEvent,responseCompletionCallback);
    fail("Expected exception");
  }
 catch (  RuntimeException e) {
    assertThat(e,sameInstance(expected));
  }
  verify(responseCompletionCallback,never()).responseSentWithFailure(argThat(new ArgumentMatcher<MessagingException>(){
    @Override public boolean matches(    Object o){
      return o instanceof MessagingException && ((MessagingException)o).getCauseException().equals(expected);
    }
  }
),eq(testEvent));
  assertThat(httpResponseCaptor.getValue().getStatusCode(),is(INTERNAL_SERVER_ERROR.getStatusCode()));
}
