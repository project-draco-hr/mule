{
  if (me.getRole() == MessageExchange.Role.CONSUMER) {
    return;
  }
  try {
    if (!me.getPattern().equals(IN_ONLY_PATTERN) && !me.getPattern().equals(ROBUST_IN_ONLY_PATTERN)) {
      throw new Exception("Unsupporte mep pattern: " + me.getPattern());
    }
    String svcName=me.getEndpoint().getServiceName().getLocalPart();
    String port=me.getEndpoint().getEndpointName();
    String oper=me.getOperation().getLocalPart();
    for (Iterator it=this.services.values().iterator(); it.hasNext(); ) {
      ServiceContext service=(ServiceContext)it.next();
      if (svcName.equals(service.getServiceName())) {
        ServicePort svcPort=service.getImport(port);
        if (svcPort != null) {
          TransactionManager mgr=(TransactionManager)this.context.getTransactionManager();
          Transaction tx=mgr.getTransaction();
          try {
            if (tx == null) {
              mgr.begin();
            }
            DOMResult r=new DOMResult();
            TransformerFactory.newInstance().newTransformer().transform(me.getMessage("in").getContent(),r);
            com.fs.pxe.sfwk.spi.MessageExchange mePxe=service.createMessageExchange(svcPort,null,oper);
            Message im=mePxe.createInputMessage();
            im.setMessage(((Document)r.getNode()).getDocumentElement());
            mePxe.input(im);
            break;
          }
  finally {
            if (tx == null) {
              mgr.commit();
            }
          }
        }
      }
    }
    me.setStatus(ExchangeStatus.DONE);
  }
 catch (  Exception e) {
    logger.error("Error handling incoming message",e);
    if (me.getPattern().equals(IN_ONLY_PATTERN)) {
      try {
        me.setStatus(ExchangeStatus.DONE);
      }
 catch (      MessagingException e2) {
        logger.error("Error setting message status to DONE",e2);
      }
    }
 else {
      me.setError(e);
    }
  }
  try {
    this.context.getDeliveryChannel().send(me);
  }
 catch (  MessagingException e) {
    logger.error("Error sending message",e);
  }
}
