{
  MuleMessage message=event.getMessage();
  MuleEvent result;
  boolean matchfound=false;
  for (Iterator<MatchableMessageProcessor> iterator=getRoutes().iterator(); iterator.hasNext(); ) {
    OutboundRouter outboundRouter=(OutboundRouter)iterator.next();
    final MuleMessage outboundRouterMessage;
    if (iterator.hasNext() && (isMatchAll() || ((outboundRouter instanceof TransformingMatchable) && ((TransformingMatchable)outboundRouter).isTransformBeforeMatch()))) {
      if (((DefaultMuleMessage)message).isConsumable()) {
        throw new MessagingException(CoreMessages.cannotCopyStreamPayload(message.getPayload().getClass().getName()),event,this);
      }
      outboundRouterMessage=new DefaultMuleMessage(message.getPayload(),message,muleContext);
    }
 else {
      outboundRouterMessage=message;
    }
    try {
      if (outboundRouter.isMatch(outboundRouterMessage)) {
        matchfound=true;
        final OutboundRouter router=outboundRouter;
        result=router.process(event);
        if (!isMatchAll()) {
          return result;
        }
      }
    }
 catch (    MessagingException e) {
      throw e;
    }
catch (    Exception e) {
      throw new RoutingException(event,outboundRouter,e);
    }
  }
  if (!matchfound && getCatchAllStrategy() != null) {
    if (logger.isDebugEnabled()) {
      logger.debug("Message did not match any routers on: " + event.getFlowConstruct().getName() + " invoking catch all strategy");
    }
    return catchAll(event);
  }
 else   if (!matchfound) {
    logger.warn("Message did not match any routers on: " + event.getFlowConstruct().getName() + " and there is no catch all strategy configured on this router.  Disposing message "+ message);
  }
  return event;
}
