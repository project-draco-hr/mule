{
  String asyncReplyCorrelationId=getAsyncReplyCorrelationId(event);
  Latch asyncReplyLatch=(Latch)locks.get(asyncReplyCorrelationId);
  boolean interruptedWhileWaiting=false;
  boolean resultAvailable=false;
  MuleEvent result=null;
  try {
    if (logger.isDebugEnabled()) {
      logger.debug("Waiting for async reply message with id: " + asyncReplyCorrelationId);
    }
    if (timeout <= 0) {
      asyncReplyLatch.await();
      resultAvailable=true;
    }
 else {
      resultAvailable=asyncReplyLatch.await(timeout,TimeUnit.MILLISECONDS);
    }
  }
 catch (  InterruptedException e) {
    interruptedWhileWaiting=true;
  }
 finally {
    locks.remove(asyncReplyCorrelationId);
    result=(MuleEvent)responseEvents.remove(asyncReplyCorrelationId);
    if (interruptedWhileWaiting) {
      Thread.currentThread().interrupt();
    }
  }
  if (interruptedWhileWaiting) {
    Thread.currentThread().interrupt();
  }
  if (resultAvailable) {
    if (result == null) {
      throw new IllegalStateException("Response MuleEvent is null");
    }
    return result;
  }
 else {
    addProcessed(asyncReplyCorrelationId);
    event.getMuleContext().fireNotification(new RoutingNotification(event.getMessage(),null,RoutingNotification.ASYNC_REPLY_TIMEOUT));
    throw new ResponseTimeoutException(CoreMessages.responseTimedOutWaitingForId((int)timeout,asyncReplyCorrelationId),event.getMessage(),null);
  }
}
