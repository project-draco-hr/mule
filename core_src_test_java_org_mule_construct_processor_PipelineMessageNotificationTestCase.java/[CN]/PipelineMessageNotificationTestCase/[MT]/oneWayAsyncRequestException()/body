{
  TriggerableMessageSource source=new TriggerableMessageSource();
  Flow pipeline=new Flow("test",muleContext);
  pipeline.setProcessingStrategy(new AsynchronousProcessingStrategy());
  final CountDownLatch latch=new CountDownLatch(1);
  pipeline.setMessageSource(source);
  pipeline.setExceptionListener(new DefaultMessagingExceptionStrategy());
  List<MessageProcessor> processors=new ArrayList<MessageProcessor>();
  processors.add(new MessageProcessor(){
    @Override public MuleEvent process(    MuleEvent event) throws MuleException {
      latch.countDown();
      throw new RuntimeException("error");
    }
  }
);
  pipeline.setMessageProcessors(processors);
  pipeline.initialise();
  pipeline.start();
  event=new DefaultMuleEvent(new DefaultMuleMessage("request",muleContext),MessageExchangePattern.ONE_WAY,pipeline);
  source.trigger(event);
  latch.await(AbstractMuleContextTestCase.RECEIVE_TIMEOUT,TimeUnit.MILLISECONDS);
  Thread.sleep(2000);
  verify(notificationManager,times(1)).fireNotification(argThat(new PipelineMessageNotificiationArgumentMatcher(PipelineMessageNotification.PROCESS_START,false)));
  verify(notificationManager,times(1)).fireNotification(argThat(new PipelineMessageNotificiationArgumentMatcher(AsyncMessageNotification.PROCESS_ASYNC_SCHEDULED,false)));
  verify(notificationManager,times(1)).fireNotification(argThat(new PipelineMessageNotificiationArgumentMatcher(PipelineMessageNotification.PROCESS_COMPLETE,false)));
  verify(notificationManager,times(1)).fireNotification(argThat(new PipelineMessageNotificiationArgumentMatcher(AsyncMessageNotification.PROCESS_ASYNC_COMPLETE,false)));
  verify(notificationManager,times(4)).fireNotification(any(PipelineMessageNotification.class));
}
