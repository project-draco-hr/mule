{
  final HttpRequestDispatcher httpRequestDispatcher=new HttpRequestDispatcher(mockHttpConnector,mockRetryTemplate,mockServerSocket,mockWorkManager);
  final Latch acceptCalledLath=new Latch();
  sustituteLifecycleManager();
  when(mockConnectorLifecycleManager.getState().isStarted()).thenReturn(true);
  when(mockRetryTemplate.execute(any(RetryCallback.class),any(WorkManager.class))).thenAnswer(new Answer<Object>(){
    @Override public Object answer(    InvocationOnMock invocationOnMock) throws Throwable {
      acceptCalledLath.release();
      throw new Exception();
    }
  }
);
  when(mockHttpConnector.getMuleContext().getExceptionListener()).thenReturn(mockExceptionListener);
  Thread dispatcherThread=createDispatcherThread(httpRequestDispatcher);
  try {
    dispatcherThread.start();
    if (!acceptCalledLath.await(WAIT_TIME,TimeUnit.MILLISECONDS)) {
      fail("retry template should be executed");
    }
    Prober prober=new PollingProber(100,1);
    prober.check(new Probe(){
      public boolean isSatisfied(){
        try {
          verify(mockExceptionListener,Mockito.atLeast(1)).handleException(Mockito.isA(Exception.class));
          return true;
        }
 catch (        AssertionError e) {
          return false;
        }
      }
      public String describeFailure(){
        return "Exception listener was not invoked";
      }
    }
);
  }
  finally {
    httpRequestDispatcher.disconnect();
  }
}
