{
  try {
    final Exchange exchange=new ExchangeImpl();
    final MuleEvent originalEvent=event;
    if (event.isAllowNonBlocking()) {
      final ReplyToHandler originalReplyToHandler=event.getReplyToHandler();
      event=new DefaultMuleEvent(event,new ReplyToHandler(){
        @Override public void processReplyTo(        MuleEvent responseEvent,        MuleMessage returnMessage,        Object replyTo) throws MuleException {
          try {
            exchange.put(CxfConstants.MULE_EVENT,responseEvent);
            exchange.put(CxfConstants.NON_BLOCKING_RESPONSE,true);
            exchange.getInMessage().getInterceptorChain().resume();
            responseEvent=(MuleEvent)exchange.get(CxfConstants.MULE_EVENT);
            responseEvent=processResponse(originalEvent,exchange,responseEvent);
            originalReplyToHandler.processReplyTo(responseEvent,responseEvent.getMessage(),replyTo);
          }
 catch (          Exception e) {
            ExceptionPayload exceptionPayload=new DefaultExceptionPayload(e);
            responseEvent.getMessage().setExceptionPayload(exceptionPayload);
            returnMessage.setOutboundProperty(HttpConnector.HTTP_STATUS_PROPERTY,500);
            responseEvent.setMessage(returnMessage);
            processExceptionReplyTo(new MessagingException(responseEvent,e),replyTo);
          }
        }
        @Override public void processExceptionReplyTo(        MessagingException exception,        Object replyTo){
          originalReplyToHandler.processExceptionReplyTo(exception,replyTo);
        }
      }
);
      OptimizedRequestContext.unsafeSetEvent(event);
    }
    MuleEvent responseEvent=sendThroughCxf(event,exchange);
    if (responseEvent == null || !responseEvent.equals(NonBlockingVoidMuleEvent.getInstance())) {
      return processResponse(event,exchange,responseEvent);
    }
    return responseEvent;
  }
 catch (  MuleException e) {
    logger.warn("Could not dispatch message to CXF!",e);
    throw e;
  }
}
