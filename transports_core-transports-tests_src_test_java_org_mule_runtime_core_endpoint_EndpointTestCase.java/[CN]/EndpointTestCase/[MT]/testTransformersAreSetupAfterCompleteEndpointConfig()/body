{
  final Connector mockConnector=mock(Connector.class);
  final EndpointURI uri=mock(EndpointURI.class);
  final List<Transformer> inputTransformers=new ArrayList<Transformer>();
  final List<Transformer> outputTransformers=new ArrayList<Transformer>();
  final String name="testEndpoint";
  final Map<String,String> properties=new HashMap<String,String>();
  final String property1="property1";
  final String value1="value1";
  properties.put(property1,value1);
  final TransactionConfig mockTransactionConfig=mock(TransactionConfig.class);
  final boolean deleteUnacceptedMessages=true;
  final EndpointSecurityFilter mockEndpointSecurityFilter=mock(EndpointSecurityFilter.class);
  final MessageExchangePattern messageExchangePattern=MessageExchangePattern.REQUEST_RESPONSE;
  final int responseTimeout=5;
  final String initialState="state1";
  final String endpointEncoding="enconding1";
  final String endpointBuilderName="builderName1";
  final MuleContext muleContext=mock(MuleContext.class);
  final RetryPolicyTemplate retryPolicyTemplate=mock(RetryPolicyTemplate.class);
  final AbstractRedeliveryPolicy redeliveryPolicy=mock(IdempotentRedeliveryPolicy.class);
  final EndpointMessageProcessorChainFactory messageProcessorsFactory=mock(EndpointMessageProcessorChainFactory.class);
  final List<MessageProcessor> messageProcessors=new ArrayList<MessageProcessor>();
  final List<MessageProcessor> responseMessageProcessors=new ArrayList<MessageProcessor>();
  final String mimeType="text/plain";
  final boolean disableTransportTransformer=true;
  Transformer mockTransformer=mock(Transformer.class,withSettings().extraInterfaces(EndpointAware.class));
  doAnswer(new Answer<Object>(){
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      AbstractEndpoint endpoint=(AbstractEndpoint)invocation.getArguments()[0];
      assertEquals(mockConnector,endpoint.getConnector());
      assertEquals(uri,endpoint.getEndpointURI());
      assertEquals(name,endpoint.getName());
      assertEquals(value1,endpoint.getProperties().get(property1));
      assertEquals(mockTransactionConfig,endpoint.getTransactionConfig());
      assertEquals(deleteUnacceptedMessages,endpoint.isDeleteUnacceptedMessages());
      assertEquals(mockEndpointSecurityFilter,endpoint.getSecurityFilter());
      assertEquals(messageExchangePattern,endpoint.getExchangePattern());
      assertEquals(responseTimeout,endpoint.getResponseTimeout());
      assertEquals(initialState,endpoint.getInitialState());
      assertEquals(endpointEncoding,endpoint.getEncoding());
      assertEquals(endpointBuilderName,endpoint.getEndpointBuilderName());
      assertEquals(muleContext,endpoint.getMuleContext());
      assertEquals(retryPolicyTemplate,endpoint.getRetryPolicyTemplate());
      assertEquals(redeliveryPolicy,endpoint.getRedeliveryPolicy());
      assertEquals(mimeType,endpoint.getMimeType());
      assertEquals(disableTransportTransformer,endpoint.isDisableTransportTransformer());
      return null;
    }
  }
).when((EndpointAware)mockTransformer).setEndpoint(any(ImmutableEndpoint.class));
  inputTransformers.add(mockTransformer);
  outputTransformers.add(mockTransformer);
  new AbstractEndpoint(mockConnector,uri,name,properties,mockTransactionConfig,deleteUnacceptedMessages,messageExchangePattern,responseTimeout,initialState,endpointEncoding,endpointBuilderName,muleContext,retryPolicyTemplate,redeliveryPolicy,messageProcessorsFactory,messageProcessors,responseMessageProcessors,disableTransportTransformer,mimeType){
    @Override protected MessageProcessor createMessageProcessorChain(    FlowConstruct flowConstruct) throws MuleException {
      return null;
    }
  }
;
}
