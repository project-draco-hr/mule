{
  return new RequestHandler(){
    @Override public void handleRequest(    HttpRequestContext requestContext,    HttpResponseReadyCallback responseCallback){
      try {
        final String httpVersion=requestContext.getRequest().getProtocol().asString();
        final boolean supportStreaming=supportsTransferEncoding(httpVersion);
        CompletionHandler<org.mule.runtime.api.message.MuleEvent,Exception,org.mule.runtime.api.message.MuleEvent> completionHandler=new CompletionHandler<org.mule.runtime.api.message.MuleEvent,Exception,org.mule.runtime.api.message.MuleEvent>(){
          @Override public void onCompletion(          org.mule.runtime.api.message.MuleEvent result,          ExceptionCallback<org.mule.runtime.api.message.MuleEvent,Exception> exceptionCallback){
            final HttpResponseBuilder responseBuilder=new HttpResponseBuilder();
            final HttpResponse httpResponse=buildResponse((MuleEvent)result,responseBuilder,supportStreaming,exceptionCallback);
            responseCallback.responseReady(httpResponse,getResponseFailureCallback(responseCallback));
          }
          @Override public void onFailure(          Exception exception){
            MessagingException messagingException=(MessagingException)exception;
            String exceptionStatusCode=ExceptionHelper.getTransportErrorMapping(HTTP.getScheme(),messagingException.getClass(),muleContext);
            Integer statusCodeFromException=exceptionStatusCode != null ? Integer.valueOf(exceptionStatusCode) : 500;
            final HttpResponseBuilder failureResponseBuilder=new HttpResponseBuilder().setStatusCode(statusCodeFromException).setReasonPhrase(messagingException.getMessage());
            addThrottlingHeaders(failureResponseBuilder);
            MuleEvent event=messagingException.getEvent();
            event.getMessage().setPayload(messagingException.getMessage());
            HttpResponse response;
            try {
              response=muleEventToHttpResponse.create(messagingException.getEvent(),failureResponseBuilder,errorResponseBuilder,supportStreaming);
            }
 catch (            MessagingException e) {
              response=new DefaultHttpResponse(new ResponseStatus(500,"Server error"),new MultiValueMap(),new EmptyHttpEntity());
            }
            responseCallback.responseReady(response,getResponseFailureCallback(responseCallback));
          }
        }
;
        sourceContext.getMessageHandler().handle(createMuleMessage(requestContext),completionHandler);
      }
 catch (      HttpRequestParsingException|IllegalArgumentException e) {
        logger.warn("Exception occurred parsing request:",e);
        sendErrorResponse(BAD_REQUEST,e.getMessage(),responseCallback);
      }
catch (      RuntimeException e) {
        logger.warn("Exception occurred processing request:",e);
        sendErrorResponse(INTERNAL_SERVER_ERROR,SERVER_PROBLEM,responseCallback);
      }
 finally {
        RequestContext.clear();
      }
    }
    private void sendErrorResponse(    final HttpConstants.HttpStatus status,    String message,    HttpResponseReadyCallback responseCallback){
      responseCallback.responseReady(new HttpResponseBuilder().setStatusCode(status.getStatusCode()).setReasonPhrase(status.getReasonPhrase()).setEntity(new ByteArrayHttpEntity(message.getBytes())).build(),new ResponseStatusCallback(){
        @Override public void responseSendFailure(        Throwable exception){
          logger.warn("Error while sending {} response {}",status.getStatusCode(),exception.getMessage());
          if (logger.isDebugEnabled()) {
            logger.debug("Exception thrown",exception);
          }
        }
        @Override public void responseSendSuccessfully(){
        }
      }
);
    }
  }
;
}
