{
  return new CollectionCorrelatorCallback(muleContext,storePrefix){
    /** 
 * This method is invoked if the shouldAggregate method is called and
 * returns true. Once this method returns an aggregated message the event
 * group is removed from the router
 * @param events the event group for this request
 * @return an aggregated message
 * @throws org.mule.runtime.core.routing.AggregationException if the aggregation
 * fails. in this scenario the whole event group is removed
 * and passed to the exception handler for this componenet
 */
    @Override public MuleEvent aggregateEvents(    EventGroup events) throws AggregationException {
      MuleEvent[] collectedEvents;
      try {
        collectedEvents=events.toArray(false);
      }
 catch (      ObjectStoreException e) {
        throw new AggregationException(events,MessageChunkAggregator.this,e);
      }
      MuleEvent firstEvent=collectedEvents[0];
      Arrays.sort(collectedEvents,eventComparator);
      ByteArrayOutputStream baos=new ByteArrayOutputStream(DEFAULT_BUFFER_SIZE);
      try {
        for (        MuleEvent event : collectedEvents) {
          baos.write(event.getMessageAsBytes());
        }
        final Builder builder=MuleMessage.builder(firstEvent.getMessage());
        try {
          builder.payload(muleContext.getObjectSerializer().deserialize(baos.toByteArray()));
        }
 catch (        SerializationException e) {
          builder.payload(baos.toByteArray());
        }
        builder.correlationGroupSize(null);
        builder.correlationSequence(null);
        return new DefaultMuleEvent(builder.build(),firstEvent,getMergedSession(events.toArray()));
      }
 catch (      Exception e) {
        throw new AggregationException(events,MessageChunkAggregator.this,e);
      }
 finally {
        IOUtils.closeQuietly(baos);
      }
    }
  }
;
}
