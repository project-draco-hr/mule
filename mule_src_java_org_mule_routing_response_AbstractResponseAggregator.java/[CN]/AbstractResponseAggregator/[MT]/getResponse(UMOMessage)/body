{
  String messageId=null;
  messageId=message.getUniqueId();
  if (logger.isDebugEnabled()) {
    logger.debug("Waiting for response for message id: " + messageId + " in "+ this);
  }
  Lock l=null;
  locksCollectionLock.lock();
  l=(Lock)locks.get(messageId);
  if (l == null) {
    logger.debug("Got response but no one is waiting for it yet. Creating latch for " + messageId + " in "+ this);
    l=new Latch();
    if (locks.get(messageId) != null) {
      throw new IllegalStateException("There is already a lock with ID: " + messageId);
    }
    locks.put(messageId,l);
  }
 else {
    logger.debug("Got latch for message: " + messageId);
  }
  locksCollectionLock.unlock();
  boolean b=false;
  try {
    logger.debug("Waiting for response to message: " + messageId);
    if (getTimeout() <= 0) {
      l.lock();
      b=true;
    }
 else {
      b=l.tryLock(this.getTimeout(),TimeUnit.MILLISECONDS);
    }
  }
 catch (  InterruptedException e) {
    logger.error(e.getMessage(),e);
  }
  if (!b) {
    if (logger.isTraceEnabled()) {
synchronized (responseEvents) {
        logger.trace("Current responses are: \n" + PropertiesHelper.propertiesToString(responseEvents,true));
      }
    }
    throw new ResponseTimeoutException(new Message(Messages.RESPONSE_TIMED_OUT_X_WAITING_FOR_ID_X,String.valueOf(getTimeout()),messageId),message,null);
  }
  UMOMessage result=(UMOMessage)responseEvents.remove(messageId);
  locks.remove(messageId);
  if (result == null) {
    throw new IllegalStateException("Response Message is null");
  }
  return result;
}
