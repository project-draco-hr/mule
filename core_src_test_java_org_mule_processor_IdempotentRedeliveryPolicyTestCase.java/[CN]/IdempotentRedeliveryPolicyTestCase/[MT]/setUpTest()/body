{
  when(mockFailingMessageProcessor.process(any(MuleEvent.class))).thenThrow(new RuntimeException("failing"));
  when(mockWaitingMessageProcessor.process(event)).thenAnswer(new Answer<MuleEvent>(){
    @Override public MuleEvent answer(    InvocationOnMock invocationOnMock) throws Throwable {
      waitingMessageProcessorExecutionLatch.countDown();
      waitLatch.await(2000,TimeUnit.MILLISECONDS);
      return mockFailingMessageProcessor.process((MuleEvent)invocationOnMock.getArguments()[0]);
    }
  }
);
  MuleLockFactory muleLockFactory=new MuleLockFactory();
  muleLockFactory.setMuleContext(mockMuleContext);
  when(mockMuleContext.getRegistry().get(MuleProperties.OBJECT_LOCK_PROVIDER)).thenReturn(new SingleServerLockProvider());
  muleLockFactory.initialise();
  when(mockMuleContext.getLockFactory()).thenReturn(muleLockFactory);
  when(mockMuleContext.getRegistry().get(MuleProperties.OBJECT_STORE_MANAGER)).thenReturn(mockObjectStoreManager);
  final InMemoryObjectStore inMemoryObjectStore=new InMemoryObjectStore();
  when(mockObjectStoreManager.getObjectStore(anyString(),anyBoolean(),anyInt(),anyInt(),anyInt())).thenAnswer(new Answer<ObjectStore>(){
    @Override public ObjectStore answer(    InvocationOnMock invocation) throws Throwable {
      return inMemoryObjectStore;
    }
  }
);
  when(event.getMessage()).thenReturn(message);
  irp.setMaxRedeliveryCount(MAX_REDELIVERY_COUNT);
  irp.setUseSecureHash(true);
  irp.setFlowConstruct(mock(FlowConstruct.class));
  irp.setMuleContext(mockMuleContext);
  irp.setListener(mockFailingMessageProcessor);
  irp.setMessageProcessor(mockDlqMessageProcessor);
}
