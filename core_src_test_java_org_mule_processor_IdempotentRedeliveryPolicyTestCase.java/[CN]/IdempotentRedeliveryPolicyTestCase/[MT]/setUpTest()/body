{
  when(mockFailingMessageProcessor.process(any(MuleEvent.class))).thenThrow(new RuntimeException("failing"));
  when(mockWaitingMessageProcessor.process(event)).thenAnswer(new Answer<MuleEvent>(){
    @Override public MuleEvent answer(    InvocationOnMock invocationOnMock) throws Throwable {
      waitingMessageProcessorExecutionLatch.countDown();
      waitLatch.await(2000,TimeUnit.MILLISECONDS);
      return mockFailingMessageProcessor.process((MuleEvent)invocationOnMock.getArguments()[0]);
    }
  }
);
  when(mockMuleContext.getRegistry().get(MuleProperties.OBJECT_STORE_MANAGER)).thenReturn(mockObjectStoreManager);
  InMemoryObjectStore inMemoryObjectStore=new InMemoryObjectStore();
  when(mockObjectStoreManager.getObjectStore(anyString(),anyBoolean(),anyInt(),anyInt(),anyInt())).thenReturn(inMemoryObjectStore);
  when(mockObjectStoreManager.getLockableObjectStore(inMemoryObjectStore)).thenReturn(inMemoryObjectStore);
  when(event.getMessage()).thenReturn(message);
  irp.setMaxRedeliveryCount(MAX_REDELIVERY_COUNT);
  irp.setUseSecureHash(true);
  irp.setFlowConstruct(mock(FlowConstruct.class));
  irp.setMuleContext(mockMuleContext);
  irp.setListener(mockFailingMessageProcessor);
  irp.setMessageProcessor(mockDlqMessageProcessor);
}
