{
  BindingOperationInfo bop=getOperation(event);
  Map<String,Object> props=getInovcationProperties(event);
  final Holder<MuleEvent> responseHolder=new Holder<MuleEvent>();
  props.put("holder",responseHolder);
  Map<String,Object> ctx=new HashMap<String,Object>();
  ctx.put(Client.REQUEST_CONTEXT,props);
  ctx.put(Client.RESPONSE_CONTEXT,props);
  Object[] arr=event.getMessage().getOutboundPropertyNames().toArray();
  String head;
  for (int i=0; i < arr.length; i++) {
    head=(String)arr[i];
    if ((head != null) && (!head.startsWith("MULE"))) {
      props.put((String)arr[i],event.getMessage().getOutboundProperty((String)arr[i]));
    }
  }
  ExchangeImpl exchange=new ExchangeImpl();
  exchange.put(StaxInEndingInterceptor.STAX_IN_NOCLOSE,Boolean.TRUE);
  if (event.isAllowNonBlocking() && event.getReplyToHandler() != null) {
    client.invoke(new ClientCallback(){
      @Override public void handleResponse(      Map<String,Object> ctx,      Object[] res){
        try {
          event.getReplyToHandler().processReplyTo(buildResponseMessage(event,responseHolder.value,res),null,null);
        }
 catch (        MuleException ex) {
          handleException(ctx,ex);
        }
      }
      @Override public void handleException(      Map<String,Object> ctx,      Throwable ex){
        event.getReplyToHandler().processExceptionReplyTo(wrapException(responseHolder.value,ex),null);
      }
    }
,bop,getArgs(event),ctx,exchange);
    return NonBlockingVoidMuleEvent.getInstance();
  }
 else {
    Object[] response=client.invoke(bop,getArgs(event),ctx,exchange);
    return buildResponseMessage(event,responseHolder.value,response);
  }
}
