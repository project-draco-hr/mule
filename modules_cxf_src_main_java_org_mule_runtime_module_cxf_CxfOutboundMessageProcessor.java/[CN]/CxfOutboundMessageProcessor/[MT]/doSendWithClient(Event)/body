{
  BindingOperationInfo bop;
  try {
    bop=getOperation(event);
  }
 catch (  Exception e) {
    throw wrapException(event,e,false);
  }
  Map<String,Object> props=getInovcationProperties(event);
  final Holder<Event> responseHolder=new Holder<>();
  props.put("holder",responseHolder);
  Map<String,Object> ctx=new HashMap<>();
  ctx.put(Client.REQUEST_CONTEXT,props);
  ctx.put(Client.RESPONSE_CONTEXT,props);
  Object[] arr=event.getMessage().getOutboundPropertyNames().toArray();
  String head;
  for (  Object element : arr) {
    head=(String)element;
    if ((head != null) && (!head.startsWith("MULE"))) {
      props.put((String)element,event.getMessage().getOutboundProperty((String)element));
    }
  }
  ExchangeImpl exchange=new ExchangeImpl();
  exchange.put(StaxInEndingInterceptor.STAX_IN_NOCLOSE,Boolean.TRUE);
  try {
    if (event.isAllowNonBlocking() && event.getReplyToHandler() != null) {
      client.invoke(new ClientCallback(){
        @Override public void handleResponse(        Map<String,Object> ctx,        Object[] res){
          try {
            event.getReplyToHandler().processReplyTo(buildResponseMessage(event,responseHolder.value,res),null,null);
          }
 catch (          MuleException ex) {
            handleException(ctx,ex);
          }
        }
        @Override public void handleException(        Map<String,Object> ctx,        Throwable ex){
          event.getReplyToHandler().processExceptionReplyTo(wrapException(responseHolder.value,ex),null);
        }
      }
,bop,getArgs(event),ctx,exchange);
      return NonBlockingVoidMuleEvent.getInstance();
    }
 else {
      Object[] response=client.invoke(bop,getArgs(event),ctx,exchange);
      return buildResponseMessage(event,(Event)exchange.get(CxfConstants.MULE_EVENT),response);
    }
  }
 catch (  Exception e) {
    throw wrapException((Event)exchange.get(CxfConstants.MULE_EVENT),e,false);
  }
}
