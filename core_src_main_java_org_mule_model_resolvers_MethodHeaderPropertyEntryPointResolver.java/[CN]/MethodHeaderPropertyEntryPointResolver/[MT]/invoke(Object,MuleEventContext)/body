{
  boolean ignoreMethod=BooleanUtils.toBoolean((Boolean)context.getMessage().getProperty(MuleProperties.MULE_IGNORE_METHOD_PROPERTY,PropertyScope.INBOUND));
  if (ignoreMethod) {
    InvocationResult result=new InvocationResult(InvocationResult.STATE_INVOKE_NOT_SUPPORTED);
    result.setErrorMessage("Property: " + MuleProperties.MULE_IGNORE_METHOD_PROPERTY + " was set so skipping this resolver: "+ this);
    return result;
  }
  Object[] payload=getPayloadFromMessage(context);
  Object methodProp=context.getMessage().getProperty(getMethodProperty(),PropertyScope.INVOCATION);
  if (methodProp == null) {
    methodProp=context.getMessage().getProperty(getMethodProperty(),PropertyScope.INBOUND);
  }
  if (methodProp == null) {
    InvocationResult result=new InvocationResult(InvocationResult.STATE_INVOKED_FAILED);
    result.setErrorMessage(CoreMessages.propertyIsNotSetOnEvent(getMethodProperty()).toString());
    return result;
  }
  Method method;
  String methodName;
  if (methodProp instanceof Method) {
    method=(Method)methodProp;
    methodName=method.getName();
  }
 else {
    methodName=methodProp.toString();
    method=getMethodByName(methodName,context);
  }
  if (method != null && method.getParameterTypes().length == 0) {
    return invokeMethod(component,method,ClassUtils.NO_ARGS_TYPE);
  }
  if (method == null) {
    Class<?>[] classTypes=ClassUtils.getClassTypes(payload);
    method=ClassUtils.getMethod(component.getClass(),methodName,classTypes);
    if (method == null) {
      InvocationResult result=new InvocationResult(InvocationResult.STATE_INVOKED_FAILED);
      result.setErrorNoMatchingMethods(component,classTypes,this);
      return result;
    }
  }
  validateMethod(component,method);
  addMethodByName(method,context);
  return invokeMethod(component,method,payload);
}
