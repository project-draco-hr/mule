{
  try {
    initCache(component,context);
  }
 catch (  Exception e) {
    InvocationResult result=new InvocationResult(this,InvocationResult.State.NOT_SUPPORTED);
    result.setErrorMessage(e.toString());
    return result;
  }
  ConcurrentHashMap<String,Method> methodCache=getMethodCache(component);
  if (methodCache.size() == 0) {
    InvocationResult result=new InvocationResult(this,InvocationResult.State.NOT_SUPPORTED);
    result.setErrorMessage("Component: " + component + " doesn't have any annotated methods, skipping.");
    return result;
  }
  Object[] payload;
  Method method=null;
  Object tempMethod=context.getMessage().removeProperty(MuleProperties.MULE_METHOD_PROPERTY,PropertyScope.INVOCATION);
  String methodName=null;
  if (tempMethod != null && tempMethod instanceof Method) {
    method=(Method)tempMethod;
  }
 else {
    methodName=(String)tempMethod;
  }
  if (methodName != null) {
    method=getMethodByName(component,methodName,context);
    if (method == null) {
      InvocationResult result=new InvocationResult(this,InvocationResult.State.NOT_SUPPORTED);
      result.setErrorMessage("Method not found: " + methodName + " on object: "+ component.getClass()+ ". If the component is a proxy there needs to be an interface on the proxy that defines this method");
      return result;
    }
    payload=getPayloadForMethod(method,component,context);
  }
 else   if (method != null) {
    payload=getPayloadForMethod(method,component,context);
  }
 else   if (methodCache.size() == 1) {
    method=methodCache.values().iterator().next();
    payload=getPayloadForMethod(method,component,context);
  }
 else {
    InvocationResult result=new InvocationResult(this,InvocationResult.State.FAILED);
    result.setErrorMessage("Component: " + component + " has more than one method annotated, which means the target method name needs to be set on the event");
    return result;
  }
  return invokeMethod(component,method,(method.getParameterTypes().length == 0 ? ClassUtils.NO_ARGS : payload));
}
