{
  if (!(flowConstruct instanceof Service)) {
    throw new IllegalArgumentException("Only the Service flow constuct is supported by the axis transport");
  }
  Service service=(Service)flowConstruct;
  AxisProperties.setProperty("axis.doAutoTypes",String.valueOf(connector.isDoAutoTypes()));
  String style=(String)endpoint.getProperties().get(AxisConnector.STYLE);
  String use=(String)endpoint.getProperties().get(AxisConnector.USE);
  String doc=(String)endpoint.getProperties().get("documentation");
  EndpointURI uri=endpoint.getEndpointURI();
  String serviceName=flowConstruct.getName();
  SOAPService existing=this.connector.getAxis().getService(serviceName);
  if (existing != null) {
    soapService=existing;
    logger.debug("Using existing service for " + serviceName);
  }
 else {
    if (style != null && style.equalsIgnoreCase("message")) {
      logger.debug("Creating Message Provider");
      soapService=new SOAPService(new MuleMsgProvider(connector));
    }
 else {
      logger.debug("Creating RPC Provider");
      soapService=new SOAPService(new MuleRPCProvider(connector));
    }
    soapService.setEngine(connector.getAxis());
  }
  String servicePath=uri.getPath();
  soapService.setOption(serviceName,this);
  soapService.setOption(AxisConnector.SERVICE_PROPERTY_SERVCE_PATH,servicePath);
  soapService.setOption(AxisConnector.SERVICE_PROPERTY_COMPONENT_NAME,serviceName);
  soapService.setName(serviceName);
  Map options=(Map)endpoint.getProperties().get(AXIS_OPTIONS);
  if (options == null) {
    options=new HashMap(2);
  }
  if (options.get("wsdlServiceElement") == null) {
    options.put("wsdlServiceElement",serviceName);
  }
  Map.Entry entry;
  for (Iterator iterator=options.entrySet().iterator(); iterator.hasNext(); ) {
    entry=(Map.Entry)iterator.next();
    soapService.setOption(entry.getKey().toString(),entry.getValue());
    logger.debug("Adding Axis option: " + entry);
  }
  Class[] interfaces=AxisServiceProxy.getInterfacesForComponent(service);
  if (interfaces.length == 0) {
    throw new InitialisationException(AxisMessages.objectMustImplementAnInterface(serviceName),service);
  }
  String methodNames="*";
  Map<?,?> methods=(Map<?,?>)endpoint.getProperties().get(AxisConnector.SOAP_METHODS);
  if (methods != null) {
    Iterator<?> i=methods.keySet().iterator();
    StringBuffer buf=new StringBuffer(64);
    while (i.hasNext()) {
      String name=(String)i.next();
      Object m=methods.get(name);
      SoapMethod method;
      if (m instanceof List) {
        method=new SoapMethod(name,(List<String>)m);
      }
 else {
        method=new SoapMethod(name,(String)m);
      }
      List<?> namedParameters=method.getNamedParameters();
      ParameterDesc[] parameters=new ParameterDesc[namedParameters.size()];
      for (int j=0; j < namedParameters.size(); j++) {
        NamedParameter parameter=(NamedParameter)namedParameters.get(j);
        byte mode=ParameterDesc.INOUT;
        if (parameter.getMode().equals(ParameterMode.IN)) {
          mode=ParameterDesc.IN;
        }
 else         if (parameter.getMode().equals(ParameterMode.OUT)) {
          mode=ParameterDesc.OUT;
        }
        parameters[j]=new ParameterDesc(parameter.getName(),mode,parameter.getType());
      }
      soapService.getServiceDescription().addOperationDesc(new OperationDesc(method.getName().getLocalPart(),parameters,method.getReturnType()));
      buf.append(method.getName().getLocalPart() + ",");
    }
    methodNames=buf.toString();
    methodNames=methodNames.substring(0,methodNames.length() - 1);
  }
 else {
    String[] methodNamesArray=AxisServiceProxy.getMethodNames(interfaces);
    StringBuffer buf=new StringBuffer(64);
    for (int i=0; i < methodNamesArray.length; i++) {
      buf.append(methodNamesArray[i]).append(",");
    }
    methodNames=buf.toString();
    methodNames=methodNames.substring(0,methodNames.length() - 1);
  }
  String className=interfaces[0].getName();
  String namespace=(String)endpoint.getProperties().get(SERVICE_NAMESPACE);
  if (namespace == null) {
    namespace=Namespaces.makeNamespace(className);
  }
  String wsdlFile=(String)endpoint.getProperties().get("wsdlFile");
  if (wsdlFile != null) {
    soapService.getServiceDescription().setWSDLFile(wsdlFile);
  }
  setOptionIfNotset(soapService,JavaProvider.OPTION_WSDL_SERVICEPORT,serviceName);
  setOptionIfNotset(soapService,JavaProvider.OPTION_CLASSNAME,className);
  setOptionIfNotset(soapService,JavaProvider.OPTION_SCOPE,"Request");
  if (StringUtils.isNotBlank(namespace)) {
    setOptionIfNotset(soapService,JavaProvider.OPTION_WSDL_TARGETNAMESPACE,namespace);
  }
  if (methodNames == null) {
    setOptionIfNotset(soapService,JavaProvider.OPTION_ALLOWEDMETHODS,"*");
  }
 else {
    setOptionIfNotset(soapService,JavaProvider.OPTION_ALLOWEDMETHODS,methodNames);
  }
  if (style != null) {
    Style s=Style.getStyle(style);
    if (s == null) {
      throw new CreateException(CoreMessages.valueIsInvalidFor(style,AxisConnector.STYLE),this);
    }
 else {
      soapService.setStyle(s);
    }
  }
  if (use != null) {
    Use u=Use.getUse(use);
    if (u == null) {
      throw new CreateException(CoreMessages.valueIsInvalidFor(use,AxisConnector.USE),this);
    }
 else {
      soapService.setUse(u);
    }
  }
  soapService.getServiceDescription().setDocumentation(doc);
  soapService.setName(serviceName);
  Component component=service.getComponent();
  if (component instanceof JavaComponent) {
    ((AbstractJavaComponent)component).getObjectFactory().addObjectInitialisationCallback(new AxisInitialisationCallback(soapService));
  }
  if (uri.getScheme().equalsIgnoreCase("servlet")) {
    connector.addServletService(soapService);
    String endpointUrl=uri.getAddress() + "/" + serviceName;
    endpointUrl=endpointUrl.replaceFirst("servlet:","http:");
    soapService.getServiceDescription().setEndpointURL(endpointUrl);
  }
 else {
    soapService.getServiceDescription().setEndpointURL(uri.getAddress() + "/" + serviceName);
  }
  if (StringUtils.isNotBlank(namespace)) {
    soapService.getServiceDescription().setDefaultNamespace(namespace);
  }
  soapService.init();
  soapService.stop();
}
