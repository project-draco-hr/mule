{
  if (!analyzed) {
    analyzed=true;
    classpathExports=newHashMap();
    activator=getProperty(BUNDLE_ACTIVATOR);
    bundleClasspath=parseHeader(getProperty(BUNDLE_CLASSPATH));
    analyzeClasspath();
    classspace=analyzeBundleClasspath(dot,bundleClasspath,contained,referred,uses);
    for (    AnalyzerPlugin plugin : getPlugins(AnalyzerPlugin.class)) {
      if (plugin instanceof AnalyzerPlugin) {
        AnalyzerPlugin analyzer=(AnalyzerPlugin)plugin;
        try {
          boolean reanalyze=analyzer.analyzeJar(this);
          if (reanalyze)           classspace=analyzeBundleClasspath(dot,bundleClasspath,contained,referred,uses);
        }
 catch (        Exception e) {
          error("Plugin Analyzer " + analyzer + " throws exception "+ e);
          e.printStackTrace();
        }
      }
    }
    if (activator != null) {
      int n=activator.lastIndexOf('.');
      if (n > 0) {
        referred.put(activator.substring(0,n),new LinkedHashMap<String,String>());
      }
    }
    referred.keySet().removeAll(contained.keySet());
    if (referred.containsKey(".")) {
      error("The default package '.' is not permitted by the Import-Package syntax. \n" + " This can be caused by compile errors in Eclipse because Eclipse creates \n" + "valid class files regardless of compile errors.\n"+ "The following package(s) import from the default package "+ getUsedBy("."));
    }
    Map<String,Map<String,String>> exportInstructions=parseHeader(getProperty(EXPORT_PACKAGE));
    Map<String,Map<String,String>> additionalExportInstructions=parseHeader(getProperty(EXPORT_CONTENTS));
    exportInstructions.putAll(additionalExportInstructions);
    Map<String,Map<String,String>> importInstructions=parseHeader(getImportPackages());
    Map<String,Map<String,String>> dynamicImports=parseHeader(getProperty(DYNAMICIMPORT_PACKAGE));
    if (dynamicImports != null) {
      referred.keySet().removeAll(dynamicImports.keySet());
    }
    Map<String,Map<String,String>> superfluous=newHashMap();
    for (Iterator<String> i=exportInstructions.keySet().iterator(); i.hasNext(); ) {
      String instr=i.next();
      if (!instr.startsWith("!"))       superfluous.put(instr,exportInstructions.get(instr));
    }
    exports=merge("export-package",exportInstructions,contained,superfluous.keySet(),null);
    for (Iterator<Map.Entry<String,Map<String,String>>> i=superfluous.entrySet().iterator(); i.hasNext(); ) {
      Map.Entry<String,Map<String,String>> entry=i.next();
      String pack=entry.getKey();
      if (isDuplicate(pack))       i.remove();
 else       if (isMetaData(pack)) {
        exports.put(pack,entry.getValue());
        i.remove();
      }
    }
    if (!superfluous.isEmpty()) {
      warning("Superfluous export-package instructions: " + superfluous.keySet());
    }
    Map<String,Map<String,String>> referredAndExported=newMap(referred);
    referredAndExported.putAll(addExportsToImports(exports));
    Set<String> extra=new TreeSet<String>(importInstructions.keySet());
    imports=merge("import-package",importInstructions,referredAndExported,extra,ignored);
    for (Iterator<String> i=extra.iterator(); i.hasNext(); ) {
      String p=i.next();
      if (p.startsWith("!") || p.indexOf('*') >= 0 || p.indexOf('?') >= 0 || p.indexOf('[') >= 0) {
        if (!isResourceOnly())         warning("Did not find matching referal for " + p);
      }
 else {
        Map<String,String> map=importInstructions.get(p);
        imports.put(p,map);
      }
    }
    augmentImports();
    doUses(exports,uses,imports);
  }
}
