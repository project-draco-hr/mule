{
  analyze();
  Manifest manifest=new Manifest();
  Attributes main=manifest.getMainAttributes();
  main.put(Attributes.Name.MANIFEST_VERSION,"1.0");
  main.putValue(BUNDLE_MANIFESTVERSION,"2");
  boolean noExtraHeaders="true".equalsIgnoreCase(getProperty(NOEXTRAHEADERS));
  if (!noExtraHeaders) {
    main.putValue(CREATED_BY,System.getProperty("java.version") + " (" + System.getProperty("java.vendor")+ ")");
    main.putValue(TOOL,"Bnd-" + getVersion());
    main.putValue(BND_LASTMODIFIED,"" + System.currentTimeMillis());
  }
  String exportHeader=printClauses(exports,"uses:|include:|exclude:|mandatory:|" + IMPORT_DIRECTIVE,true);
  if (exportHeader.length() > 0)   main.putValue(EXPORT_PACKAGE,exportHeader);
 else   main.remove(EXPORT_PACKAGE);
  Map<String,Map<String,String>> temp=removeKeys(imports,"java.");
  if (!temp.isEmpty()) {
    main.putValue(IMPORT_PACKAGE,printClauses(temp,"resolution:"));
  }
 else {
    main.remove(IMPORT_PACKAGE);
  }
  temp=newMap(contained);
  temp.keySet().removeAll(exports.keySet());
  if (!temp.isEmpty())   main.putValue(PRIVATE_PACKAGE,printClauses(temp,""));
 else   main.remove(PRIVATE_PACKAGE);
  if (!ignored.isEmpty()) {
    main.putValue(IGNORE_PACKAGE,printClauses(ignored,""));
  }
 else {
    main.remove(IGNORE_PACKAGE);
  }
  if (bundleClasspath != null && !bundleClasspath.isEmpty())   main.putValue(BUNDLE_CLASSPATH,printClauses(bundleClasspath,""));
 else   main.remove(BUNDLE_CLASSPATH);
  Map<String,Map<String,String>> l=doServiceComponent(getProperty(SERVICE_COMPONENT));
  if (!l.isEmpty())   main.putValue(SERVICE_COMPONENT,printClauses(l,""));
 else   main.remove(SERVICE_COMPONENT);
  for (Enumeration<?> h=getProperties().propertyNames(); h.hasMoreElements(); ) {
    String header=(String)h.nextElement();
    if (header.trim().length() == 0) {
      warning("Empty property set with value: " + getProperties().getProperty(header));
      continue;
    }
    if (!Character.isUpperCase(header.charAt(0))) {
      if (header.charAt(0) == '@')       doNameSection(manifest,header);
      continue;
    }
    if (header.equals(BUNDLE_CLASSPATH) || header.equals(EXPORT_PACKAGE) || header.equals(IMPORT_PACKAGE))     continue;
    if (Verifier.HEADER_PATTERN.matcher(header).matches()) {
      String value=getProperty(header);
      if (value != null && main.getValue(header) == null) {
        if (value.trim().length() == 0)         main.remove(header);
 else         main.putValue(header,value);
      }
    }
 else {
    }
  }
  String bsn=getBsn();
  if (main.getValue(BUNDLE_SYMBOLICNAME) == null) {
    main.putValue(BUNDLE_SYMBOLICNAME,bsn);
  }
  if (main.getValue(BUNDLE_NAME) == null) {
    main.putValue(BUNDLE_NAME,bsn);
  }
  if (main.getValue(BUNDLE_VERSION) == null)   main.putValue(BUNDLE_VERSION,"0");
  merge(manifest,dot.getManifest());
  Map<String,Map<String,String>> removes=parseHeader(getProperty(REMOVE_HEADERS));
  for (Iterator<String> i=removes.keySet().iterator(); i.hasNext(); ) {
    String header=i.next();
    for (Iterator<Object> j=main.keySet().iterator(); j.hasNext(); ) {
      Attributes.Name attr=(Attributes.Name)j.next();
      if (attr.toString().matches(header)) {
        j.remove();
        progress("Removing header: " + header);
      }
    }
  }
  dot.setManifest(manifest);
  return manifest;
}
