{
  Object responseId=getCallResponseAggregateIdentifier(message);
  if (logger.isDebugEnabled()) {
    logger.debug("Waiting for response for message id: " + responseId + " in "+ this);
  }
  Latch l=(Latch)locks.get(responseId);
  if (l == null) {
    if (logger.isDebugEnabled()) {
      logger.debug("Got response but no one is waiting for it yet. Creating latch for " + responseId + " in "+ this);
    }
    l=new Latch();
    Latch previous=(Latch)locks.putIfAbsent(responseId,l);
    if (previous != null) {
      l=previous;
    }
  }
  if (logger.isDebugEnabled()) {
    logger.debug("Got latch for message: " + responseId);
  }
  UMOMessage result;
  boolean resultAvailable=false;
  try {
    if (logger.isDebugEnabled()) {
      logger.debug("Waiting for response to message: " + responseId);
    }
    if (this.getTimeout() <= 0) {
      l.await();
      resultAvailable=true;
    }
 else {
      resultAvailable=l.await(this.getTimeout(),TimeUnit.MILLISECONDS);
    }
  }
 catch (  InterruptedException e) {
    logger.error(e.getMessage(),e);
  }
 finally {
    locks.remove(responseId);
    result=(UMOMessage)responseEvents.remove(responseId);
  }
  if (!resultAvailable) {
    if (logger.isTraceEnabled()) {
      logger.trace("Current responses are: \n" + MapUtils.toString(responseEvents,true));
    }
    throw new ResponseTimeoutException(new Message(Messages.RESPONSE_TIMED_OUT_X_WAITING_FOR_ID_X,String.valueOf(getTimeout()),responseId),message,null);
  }
  if (result == null) {
    throw new IllegalStateException("Response Message is null");
  }
  if (logger.isDebugEnabled()) {
    logger.debug("remaining locks  : " + locks.keySet());
    logger.debug("remaining results: " + responseEvents.keySet());
  }
  return result;
}
