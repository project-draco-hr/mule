{
  when(mockContext.supportsAsynchronousProcessing()).thenReturn(true);
  doAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocationOnMock) throws Throwable {
      ResponseCompletionCallback callback=(ResponseCompletionCallback)invocationOnMock.getArguments()[1];
      callback.responseSentSuccessfully();
      return null;
    }
  }
).when(mockTemplate).sendFailureResponseToClient(any(MessagingException.class),any(ResponseCompletionCallback.class));
  doAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocationOnMock) throws Throwable {
      ResponseCompletionCallback callback=(ResponseCompletionCallback)invocationOnMock.getArguments()[1];
      callback.responseSentSuccessfully();
      return null;
    }
  }
).when(mockTemplate).sendResponseToClient(any(MuleEvent.class),any(ResponseCompletionCallback.class));
  when(mockContext.getFlowExecutionWorkManager()).thenReturn(mockWorkManager);
  doAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocationOnMock) throws Throwable {
      Work work=(Work)invocationOnMock.getArguments()[0];
      work.run();
      return null;
    }
  }
).when(mockWorkManager).scheduleWork(any(Work.class));
  when(mockTemplate.getMuleEvent()).thenReturn(mockMuleEvent);
}
