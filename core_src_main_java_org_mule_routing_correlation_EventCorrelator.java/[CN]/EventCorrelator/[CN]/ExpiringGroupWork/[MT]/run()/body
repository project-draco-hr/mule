{
  while (true) {
    List<EventGroup> expired=new ArrayList<EventGroup>(1);
    for (    Object o : eventGroups.values()) {
      EventGroup group=(EventGroup)o;
      if ((group.getCreated() + getTimeout() * MILLI_TO_NANO_MULTIPLIER) < System.nanoTime()) {
        expired.add(group);
      }
    }
    if (expired.size() > 0) {
      for (      Object anExpired : expired) {
        EventGroup group=(EventGroup)anExpired;
        eventGroups.remove(group.getGroupId());
        locks.remove(group.getGroupId());
        final FlowConstruct service=group.toArray()[0].getFlowConstruct();
        if (isFailOnTimeout()) {
          final MuleMessageCollection messageCollection=group.toMessageCollection();
          context.fireNotification(new RoutingNotification(messageCollection,null,RoutingNotification.CORRELATION_TIMEOUT));
          service.getExceptionListener().exceptionThrown(new CorrelationTimeoutException(CoreMessages.correlationTimedOut(group.getGroupId()),messageCollection));
        }
 else {
          if (logger.isDebugEnabled()) {
            logger.debug(MessageFormat.format("Aggregator expired, but ''failOnTimeOut'' is false. Forwarding {0} events out of {1} " + "total for group ID: {2}",group.size(),group.expectedSize(),group.getGroupId()));
          }
          try {
            if (!(group.getCreated() + groupTimeToLive < System.currentTimeMillis())) {
              MuleMessage msg=callback.aggregateEvents(group);
              MuleEvent newEvent=new DefaultMuleEvent(msg,group.toArray()[0].getEndpoint(),new DefaultMuleSession((Service)service,context));
              if (!expiredAndDispatchedGroups.containsKey(group.getGroupId())) {
                if (timeoutMessageProcessor != null) {
                  timeoutMessageProcessor.process(newEvent);
                }
 else {
                  if (!(service instanceof Service)) {
                    throw new UnsupportedOperationException("EventAggregator is only supported with Service");
                  }
                  ((Service)service).dispatchEvent(newEvent);
                }
                expiredAndDispatchedGroups.put(group.getGroupId(),group.getCreated());
              }
 else {
                logger.warn(MessageFormat.format("Discarding group {0}",group.getGroupId()));
              }
            }
          }
 catch (          Exception e) {
            service.getExceptionListener().exceptionThrown(e);
          }
        }
      }
    }
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      break;
    }
  }
}
