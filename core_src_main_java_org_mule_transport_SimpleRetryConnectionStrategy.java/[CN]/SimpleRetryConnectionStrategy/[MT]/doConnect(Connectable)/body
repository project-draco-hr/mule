{
  while (true) {
    final Boolean recursiveCallDetected=(Boolean)ObjectUtils.defaultIfNull(called.get(),Boolean.FALSE);
    if (!recursiveCallDetected.booleanValue()) {
      retryCounter.countRetry();
    }
    called.set(Boolean.TRUE);
    try {
      connectable.connect();
      if (logger.isDebugEnabled()) {
        logger.debug("Successfully connected to " + getDescription(connectable));
      }
      break;
    }
 catch (    InterruptedException ie) {
      throw new FatalConnectException(CoreMessages.reconnectStrategyFailed(this.getClass(),this.getDescription(connectable)),ie,connectable);
    }
catch (    Exception e) {
      if (e instanceof FatalConnectException) {
        throw (FatalConnectException)e;
      }
      if (retryCount != RETRY_COUNT_FOREVER && retryCounter.current().get() >= retryCount) {
        throw new FatalConnectException(CoreMessages.reconnectStrategyFailed(this.getClass(),this.getDescription(connectable)),e,connectable);
      }
      if (logger.isErrorEnabled()) {
        StringBuffer msg=new StringBuffer(512);
        msg.append("Failed to connect/reconnect: ").append(getDescription(connectable));
        Throwable t=ExceptionHelper.getRootException(e);
        msg.append(". Root Exception was: ").append(ExceptionHelper.writeException(t));
        logger.error(msg.toString(),e);
      }
      if (logger.isInfoEnabled()) {
        logger.info("Waiting for " + retryFrequency + "ms before reconnecting. Failed attempt "+ retryCounter.current().get()+ " of "+ (retryCount != RETRY_COUNT_FOREVER ? String.valueOf(retryCount) : "unlimited"));
      }
      try {
        Thread.sleep(retryFrequency);
      }
 catch (      InterruptedException e1) {
        throw new FatalConnectException(CoreMessages.reconnectStrategyFailed(this.getClass(),this.getDescription(connectable)),e,connectable);
      }
    }
 finally {
      called.set(Boolean.FALSE);
    }
  }
}
