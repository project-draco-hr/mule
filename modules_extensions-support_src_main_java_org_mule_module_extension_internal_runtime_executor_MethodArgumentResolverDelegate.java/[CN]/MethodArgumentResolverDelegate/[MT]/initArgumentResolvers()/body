{
  final Class<?>[] parameterTypes=method.getParameterTypes();
  if (isEmpty(parameterTypes)) {
    argumentResolvers=new ArgumentResolver[]{};
    return;
  }
  argumentResolvers=new ArgumentResolver[parameterTypes.length];
  Annotation[][] parameterAnnotations=method.getParameterAnnotations();
  final List<String> paramNames=MuleExtensionAnnotationParser.getParamNames(method);
  for (int i=0; i < parameterTypes.length; i++) {
    final Class<?> parameterType=parameterTypes[i];
    Map<Class<? extends Annotation>,Annotation> annotations=toMap(parameterAnnotations[i]);
    ArgumentResolver<?> argumentResolver;
    if (annotations.containsKey(UseConfig.class)) {
      argumentResolver=CONFIGURATION_ARGUMENT_RESOLVER;
    }
 else     if (annotations.containsKey(Connection.class)) {
      argumentResolver=CONNECTOR_ARGUMENT_RESOLVER;
    }
 else     if (MuleEvent.class.isAssignableFrom(parameterType)) {
      argumentResolver=EVENT_ARGUMENT_RESOLVER;
    }
 else     if (MuleMessage.class.isAssignableFrom(parameterType)) {
      argumentResolver=MESSAGE_ARGUMENT_RESOLVER;
    }
 else     if (annotations.containsKey(ParameterGroup.class)) {
      argumentResolver=new ParameterGroupArgumentResolver(parameterType);
    }
 else     if (ContentMetadata.class.isAssignableFrom(parameterType)) {
      if (isVoid(method)) {
        throw new IllegalModelDefinitionException(String.format("Operation method '%s' is void yet requires a '%s' argument which allows changing the content metadata." + " Mutating the content metadata requires an operation with a return type.",method.getName(),ContentMetadata.class.getName()));
      }
      argumentResolver=CONTENT_METADATA_ARGUMENT_RESOLVER;
    }
 else     if (ContentType.class.isAssignableFrom(parameterType)) {
      argumentResolver=CONTENT_TYPE_ARGUMENT_RESOLVER;
    }
 else {
      argumentResolver=new ByParameterNameArgumentResolver<>(paramNames.get(i));
    }
    argumentResolvers[i]=argumentResolver;
  }
}
