{
  DefaultMuleEvent event=null;
  QueueSession queueSession=muleContext.getQueueManager().getQueueSession();
  while (!lifecycleState.isStopped()) {
    try {
      if (lifecycleState.isPhaseComplete(Pausable.PHASE_NAME)) {
        waitIfPaused();
        if (lifecycleState.isStopping()) {
          queueDraining.set(true);
          if (!isQueuePersistent() && (queueSession != null && getQueueSize() > 0)) {
            logger.warn(CoreMessages.stopPausedSedaStageNonPeristentQueueMessageLoss(getQueueSize(),getQueueName()));
          }
          queueDraining.set(false);
          break;
        }
      }
      if (lifecycleState.isStopping()) {
        if (isQueuePersistent() || queueSession == null || getQueueSize() <= 0) {
          queueDraining.set(false);
          break;
        }
      }
      event=(DefaultMuleEvent)dequeue();
    }
 catch (    InterruptedException ie) {
      queueDraining.set(false);
      break;
    }
catch (    Exception e) {
      SystemExceptionHandler exceptionListener=muleContext.getExceptionListener();
      if (e instanceof MuleException) {
        exceptionListener.handleException(e);
      }
 else {
        exceptionListener.handleException(new MessagingException(CoreMessages.eventProcessingFailedFor(getStageDescription()),event,e));
      }
    }
    if (event != null) {
      try {
        if (isStatsEnabled()) {
          queueStatistics.decQueuedEvent();
        }
        if (logger.isDebugEnabled()) {
          logger.debug(MessageFormat.format("{0}: Dequeued event from {1}",getStageDescription(),getQueueName()));
        }
        Work work=new SedaStageWorker(event);
        if (doThreading) {
          workManagerSource.getWorkManager().scheduleWork(work,WorkManager.INDEFINITE,null,this);
        }
 else {
          work.run();
        }
      }
 catch (      Exception e) {
        event.getFlowConstruct().getExceptionListener().handleException(e,event);
      }
    }
  }
}
