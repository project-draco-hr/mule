{
  ManagedMap values=new ManagedMap();
  NodeList properties=element.getChildNodes();
  for (int index=0; index < properties.getLength(); index++) {
    Node property=properties.item(index);
    if (property instanceof Element) {
      String localName=property.getLocalName();
      String ref=((Element)property).getAttribute("ref");
      String key="";
      if ("username-token-validator".equals(localName)) {
        key=SecurityConstants.USERNAME_TOKEN_VALIDATOR;
      }
 else       if ("saml1-token-validator".equals(localName)) {
        key=SecurityConstants.SAML1_TOKEN_VALIDATOR;
      }
 else       if ("saml2-token-validator".equals(localName)) {
        key=SecurityConstants.SAML2_TOKEN_VALIDATOR;
      }
 else       if ("timestamp-token-validator".equals(localName)) {
        key=SecurityConstants.TIMESTAMP_TOKEN_VALIDATOR;
      }
 else       if ("signature-token-validator".equals(localName)) {
        key=SecurityConstants.SIGNATURE_TOKEN_VALIDATOR;
      }
 else       if ("bst-token-validator".equals(localName)) {
        key=SecurityConstants.BST_TOKEN_VALIDATOR;
      }
 else {
        throw new IllegalArgumentException("Illegal custom validator: " + localName);
      }
      values.put(key,new RuntimeBeanReference(ref));
    }
  }
  builder.addPropertyValue("sourceMap",values);
  builder.addPropertyValue("targetMapClass",super.getBeanClass(element));
  postProcess(parserContext,getBeanAssembler(element,builder),element);
  builder.getBeanDefinition().setAttribute(MuleHierarchicalBeanDefinitionParserDelegate.MULE_NO_RECURSE,Boolean.TRUE);
}
