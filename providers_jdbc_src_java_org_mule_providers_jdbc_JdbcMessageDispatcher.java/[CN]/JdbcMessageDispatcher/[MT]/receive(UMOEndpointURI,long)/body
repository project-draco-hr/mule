{
  logger.debug("Trying to receive a message with a timeout of " + timeout);
  String[] stmts=this.connector.getReadAndAckStatements(endpointUri,null);
  String readStmt=stmts[0];
  String ackStmt=stmts[1];
  List readParams=new ArrayList();
  List ackParams=new ArrayList();
  readStmt=JdbcConnector.parseStatement(readStmt,readParams);
  ackStmt=JdbcConnector.parseStatement(ackStmt,ackParams);
  Connection con=null;
  QueryRunner runner=new QueryRunner();
  ResultSetHandler handler=new MapHandler();
  long t0=System.currentTimeMillis();
  try {
    Object ds=this.connector.getDataSource();
    if (ds instanceof XADataSource) {
      con=((XADataSource)ds).getXAConnection().getConnection();
    }
 else {
      con=((DataSource)ds).getConnection();
    }
    if (timeout < 0) {
      timeout=Long.MAX_VALUE;
    }
    Object result=null;
    do {
      result=runner.query(con,readStmt,JdbcConnector.getParams(endpointUri,readParams,null),handler);
      if (result != null) {
        logger.debug("Received: " + result);
        break;
      }
      long sleep=Math.min(this.connector.getPollingFrequency(),timeout - (System.currentTimeMillis() - t0));
      if (sleep > 0) {
        logger.debug("No results, sleeping for " + sleep);
        Thread.sleep(sleep);
      }
 else {
        logger.debug("Timeout");
        return null;
      }
    }
 while (true);
    if (result != null && ackStmt != null) {
      int nbRows=runner.update(con,ackStmt,JdbcConnector.getParams(endpointUri,ackParams,result));
      if (nbRows != 1) {
        logger.warn("Row count for ack should be 1 and not " + nbRows);
      }
    }
    UMOMessageAdapter msgAdapter=this.connector.getMessageAdapter(result);
    UMOMessage message=new MuleMessage(msgAdapter);
    DbUtils.commitAndClose(con);
    return message;
  }
 catch (  Exception e) {
    DbUtils.closeQuietly(con);
    throw e;
  }
}
