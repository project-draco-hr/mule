{
  boolean done=false;
  int offset=1;
  while (!done) {
synchronized (folderLock) {
      if (getLifecycleState().isStopping() || getLifecycleState().isStopped()) {
        break;
      }
      try {
        try {
          if (!folder.isOpen()) {
            folder.open(Folder.READ_WRITE);
          }
        }
 catch (        Exception e) {
          handleFolderException("opening",e);
        }
        int count=folder.getMessageCount();
        int batchSize=getBatchSize(count);
        if (count > 0) {
          int limit=Math.min(count,offset + batchSize - 1);
          Message[] messages=folder.getMessages(offset,limit);
          MessageCountEvent event=new MessageCountEvent(folder,MessageCountEvent.ADDED,true,messages);
          messagesAdded(event);
          if (!castConnector().isDeleteReadMessages()) {
            offset+=batchSize;
          }
        }
 else         if (count == -1) {
          throw new MessagingException("Cannot monitor folder: " + folder.getFullName() + " as folder is closed");
        }
        done=(offset >= count) || (batchSize >= count);
      }
 catch (      MessagingException e) {
        done=true;
        getEndpoint().getMuleContext().getExceptionListener().handleException(e);
      }
 finally {
        try {
          closeFolder();
        }
 catch (        Exception e) {
          logger.error(String.format(FOLDER_EXCEPTION_FORMAT,"closing",folder.getFullName(),e.getMessage()));
        }
      }
    }
  }
}
