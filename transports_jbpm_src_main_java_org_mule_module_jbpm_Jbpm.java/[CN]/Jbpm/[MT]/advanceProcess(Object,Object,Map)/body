{
  int waitTime=0;
  Execution execution=processEngine.getExecutionService().findExecutionById((String)executionId);
  while (execution == null && waitTime < PROCESS_CREATION_WAIT) {
    Thread.sleep(PROCESS_CREATION_WAIT / 10);
    waitTime+=(PROCESS_CREATION_WAIT / 10);
    execution=processEngine.getExecutionService().findExecutionById((String)executionId);
  }
  if (execution == null) {
    throw new IllegalArgumentException("No process execution found with id = " + executionId + " (it may have already terminated)");
  }
  String processId;
  if (execution.getProcessInstance() != null) {
    processId=execution.getProcessInstance().getId();
  }
 else {
    processId=execution.getId();
  }
  if (variables != null && !variables.isEmpty()) {
    processEngine.getExecutionService().setVariables((String)executionId,variables);
  }
synchronized (this) {
    processEngine.getExecutionService().signalExecutionById((String)executionId,(String)signalName,variables);
  }
  ProcessInstance process=processEngine.getExecutionService().findProcessInstanceById(processId);
  if (process == null) {
    process=new EndedProcess(processId);
  }
  return process;
}
