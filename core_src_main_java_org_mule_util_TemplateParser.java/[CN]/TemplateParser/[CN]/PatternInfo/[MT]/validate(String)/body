{
  Stack<Character> openDelimiterStack=new Stack<Character>();
  int charCount=expression.length();
  int index=0;
  char nextChar=' ';
  char preDelim=0;
  char open;
  char close;
  boolean inExpression=false;
  int expressionCount=0;
  if (prefix.length() == 2) {
    preDelim=prefix.charAt(0);
    open=prefix.charAt(1);
  }
 else {
    open=prefix.charAt(0);
  }
  close=suffix.charAt(0);
  for (; index < charCount; index++) {
    nextChar=expression.charAt(index);
    if (preDelim != 0 && nextChar == preDelim) {
      if (inExpression) {
        if (index < charCount && expression.charAt(index + 1) == open) {
          throw new IllegalArgumentException(String.format("Character %s at position %s suggests an expression inside an expression",open,index));
        }
      }
 else       if (openDelimiterStack.isEmpty()) {
        openDelimiterStack.push(nextChar);
        nextChar=expression.charAt(++index);
        if (nextChar != open) {
          throw new IllegalArgumentException(String.format("Character %s at position %s must appear immediately after %s",open,index,preDelim));
        }
        inExpression=true;
      }
 else {
        throw new IllegalArgumentException(String.format("Character %s at position %s appears out of sequence. Character cannot appear after %s",nextChar,index,openDelimiterStack.pop()));
      }
    }
    if (nextChar == open) {
      if (preDelim == 0 || inExpression) {
        openDelimiterStack.push(nextChar);
      }
 else       if (openDelimiterStack.size() == 1 && openDelimiterStack.peek().equals(preDelim)) {
        openDelimiterStack.push(nextChar);
      }
 else {
        throw new IllegalArgumentException(String.format("Character %s at position %s appears out of sequence. Character cannot appear after %s",nextChar,index,preDelim));
      }
    }
 else     if (nextChar == close) {
      if (openDelimiterStack.isEmpty()) {
        throw new IllegalArgumentException(String.format("Character %s at position %s appears out of sequence",nextChar,index));
      }
 else {
        openDelimiterStack.pop();
        if (preDelim != 0 && openDelimiterStack.peek() == preDelim) {
          openDelimiterStack.pop();
        }
        if (openDelimiterStack.isEmpty()) {
          inExpression=false;
          expressionCount++;
        }
      }
    }
  }
  if (expressionCount == 0) {
    throw new IllegalArgumentException("Not an expression: " + expression);
  }
}
