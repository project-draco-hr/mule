{
  final Object replyToDestination=event.getReplyToDestination();
  final ReplyToHandler replyToHandler=event.getReplyToHandler();
  ReplyToHandler nonBlockingReplyToHandler=new ExceptionHandlingReplyToHandlerDecorator(new ReplyToHandler(){
    @Override public void processReplyTo(    MuleEvent result,    MuleMessage returnMessage,    Object replyTo) throws MuleException {
      replyToHandler.processReplyTo(createReturnEventForParentFlowConstruct(result,event),null,null);
    }
    @Override public void processExceptionReplyTo(    MessagingException exception,    Object replyTo){
      exception.setProcessedEvent(createReturnEventForParentFlowConstruct(exception.getEvent(),event));
      replyToHandler.processExceptionReplyTo(exception,null);
    }
  }
,getExceptionListener());
  final MuleEvent newEvent=createMuleEventForCurrentFlow(event,replyToDestination,replyToHandler);
  try {
    ExecutionTemplate<MuleEvent> executionTemplate=ErrorHandlingExecutionTemplate.createErrorHandlingExecutionTemplate(muleContext,getExceptionListener());
    MuleEvent result=executionTemplate.execute(new ExecutionCallback<MuleEvent>(){
      @Override public MuleEvent process() throws Exception {
        return pipeline.process(newEvent);
      }
    }
);
    return createReturnEventForParentFlowConstruct(result,event);
  }
 catch (  MessagingException e) {
    e.setProcessedEvent(createReturnEventForParentFlowConstruct(e.getEvent(),event));
    throw e;
  }
catch (  Exception e) {
    resetRequestContextEvent(event);
    throw new DefaultMuleException(CoreMessages.createStaticMessage("Flow execution exception"),e);
  }
}
