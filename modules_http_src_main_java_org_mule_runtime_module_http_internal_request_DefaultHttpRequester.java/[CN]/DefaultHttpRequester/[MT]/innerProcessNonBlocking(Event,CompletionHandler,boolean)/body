{
  final HttpAuthentication authentication=requestConfig.getAuthentication();
  final HttpRequest httpRequest=createHttpRequest(muleEvent,authentication);
  notificationHelper.fireNotification(this,muleEvent,httpRequest.getUri(),flowConstruct,MESSAGE_REQUEST_BEGIN);
  getHttpClient().send(httpRequest,resolveResponseTimeout(muleEvent),followRedirects.resolveBooleanValue(muleEvent),resolveAuthentication(muleEvent),new BlockingCompletionHandler<HttpResponse,Exception,Void>(){
    @Override public void onFailure(    Exception exception){
      MessagingException msgException=new MessagingException(CoreMessages.createStaticMessage(getErrorMessage(httpRequest)),resetMuleEventForNewThread(muleEvent),exception,DefaultHttpRequester.this);
      checkIfRemotelyClosed(exception);
      completionHandler.onFailure(msgException);
    }
    @Override protected void doOnCompletion(    HttpResponse httpResponse){
      try {
        Event resultEvent=httpResponseToMuleEvent.convert(muleEvent,httpResponse,httpRequest.getUri());
        notificationHelper.fireNotification(this,resultEvent,httpRequest.getUri(),flowConstruct,MESSAGE_REQUEST_END);
        resetMuleEventForNewThread(resultEvent);
        if (resendRequest(resultEvent,checkRetry,authentication)) {
          consumePayload(resultEvent);
          innerProcessNonBlocking(muleEvent,completionHandler,false);
        }
 else {
          validateResponse(resultEvent);
          completionHandler.onCompletion(resultEvent,createCompletionExceptionCallback(resultEvent));
        }
      }
 catch (      MessagingException messagingException) {
        completionHandler.onFailure(messagingException);
      }
catch (      MuleException muleException) {
        completionHandler.onFailure(new MessagingException(resetMuleEventForNewThread(muleEvent),muleException,DefaultHttpRequester.this));
      }
 finally {
        setCurrentEvent(null);
      }
    }
    private Event resetMuleEventForNewThread(    Event event){
      setCurrentEvent(event);
      return event;
    }
  }
);
}
