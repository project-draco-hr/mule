{
  if (object == null || pattern == null) {
    return false;
  }
  if (this.pattern.equals(object)) {
    return true;
  }
  String[] currentPatterns=this.patterns;
  if (currentPatterns != null) {
    for (    String pattern : currentPatterns) {
      boolean foundMatch;
      if ("*".equals(pattern) || "**".equals(pattern)) {
        return true;
      }
      String candidate=object.toString();
      if (!isCaseSensitive()) {
        pattern=pattern.toLowerCase();
        candidate=candidate.toLowerCase();
      }
      int i=pattern.indexOf('*');
      if (i == -1) {
        foundMatch=pattern.equals(candidate);
      }
 else {
        int i2=pattern.indexOf('*',i + 1);
        if (i2 > 1) {
          foundMatch=candidate.indexOf(pattern.substring(1,i2)) > -1;
        }
 else         if (i == 0) {
          foundMatch=candidate.endsWith(pattern.substring(1));
        }
 else {
          foundMatch=candidate.startsWith(pattern.substring(0,i));
        }
      }
      if (foundMatch) {
        return true;
      }
 else       if (pattern.endsWith("+") && pattern.length() > 1) {
        logger.warn("wildcard-filter for payload based filtering is deprecated. Use expression" + "-filter or payload-type-filter instead");
        return filterByClassName(object,pattern);
      }
    }
  }
  return false;
}
