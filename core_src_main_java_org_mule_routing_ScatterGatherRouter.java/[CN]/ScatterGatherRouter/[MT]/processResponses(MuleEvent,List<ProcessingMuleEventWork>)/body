{
  List<MuleEvent> responses=new ArrayList<MuleEvent>(works.size());
  long remainingTimeout=timeout;
  for (int routeIndex=0; routeIndex < works.size(); routeIndex++) {
    MuleEvent response=null;
    Exception exception=null;
    ProcessingMuleEventWork work=works.get(routeIndex);
    MessageProcessor route=routes.get(routeIndex);
    long startedAt=System.currentTimeMillis();
    try {
      response=work.getResult(remainingTimeout,TimeUnit.MILLISECONDS);
    }
 catch (    ResponseTimeoutException e) {
      exception=e;
    }
catch (    InterruptedException e) {
      throw new DefaultMuleException(MessageFactory.createStaticMessage(String.format("Was interrupted while waiting for route %d",routeIndex)),e);
    }
catch (    Exception e) {
      exception=new DispatchException(MessageFactory.createStaticMessage(String.format("route number %d failed to be executed",routeIndex)),event,route,e);
    }
    remainingTimeout-=System.currentTimeMillis() - startedAt;
    if (exception != null) {
      if (logger.isDebugEnabled()) {
        logger.debug(String.format("route %d generated exception for MuleEvent %s",routeIndex,event.getId()),exception);
      }
      response=DefaultMuleEvent.copy(event);
      response.getMessage().setExceptionPayload(new DefaultExceptionPayload(exception));
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug(String.format("route %d executed successfully for event %s",routeIndex,event.getId()));
      }
    }
    responses.add(response);
  }
  return aggregationStrategy.aggregate(new AggregationContext(event,responses));
}
