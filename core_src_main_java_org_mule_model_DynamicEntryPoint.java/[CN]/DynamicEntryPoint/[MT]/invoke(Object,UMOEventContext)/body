{
  Object payload=null;
  Method method=null;
  Boolean ignoreMethod=(Boolean)context.getMessage().removeProperty(MuleProperties.MULE_IGNORE_METHOD_PROPERTY);
  boolean ignore=(ignoreMethod == null ? false : ignoreMethod.booleanValue());
  if (!ignore) {
    Object methodOverride=context.getMessage().removeProperty(MuleProperties.MULE_METHOD_PROPERTY);
    if (methodOverride instanceof Method) {
      method=(Method)methodOverride;
    }
 else     if (methodOverride != null) {
      payload=context.getTransformedMessage();
      method=ClassUtils.getMethod(methodOverride.toString(),ClassUtils.getClassTypes(payload),component.getClass());
      validateMethod(component,method,methodOverride.toString());
    }
  }
  if (method == null) {
    if (component instanceof Callable) {
      method=Callable.class.getMethods()[0];
      payload=context;
    }
    if (method == null) {
      method=getMethod(component,context);
      if (method == null) {
        payload=context.getTransformedMessage();
        method=getMethod(component,payload);
        if (method != null) {
          RequestContext.rewriteEvent(new MuleMessage(payload,context.getMessage()));
        }
      }
 else {
        payload=context;
      }
    }
  }
  if (method != null) {
    validateMethod(component,method,method.getName());
    currentMethod=method;
    if (payload == null) {
      payload=context.getTransformedMessage();
      RequestContext.rewriteEvent(new MuleMessage(payload,context.getMessage()));
    }
    return invokeCurrent(component,payload);
  }
  List methods=ClassUtils.getSatisfiableMethods(component.getClass(),ClassUtils.getClassTypes(context),true,false,ignoreMethods);
  if (methods.size() > 1) {
    TooManySatisfiableMethodsException tmsmex=new TooManySatisfiableMethodsException(component.getClass());
    throw new InvocationTargetException(tmsmex,"There must be only one method accepting " + context.getClass().getName() + " in component "+ component.getClass().getName());
  }
 else   if (methods.size() == 1) {
    if (logger.isDebugEnabled()) {
      logger.debug("Dynamic Entrypoint using method: " + component.getClass().getName() + "."+ ((Method)methods.get(0)).getName()+ "("+ context.getClass().getName()+ ")");
    }
    addMethod(component,(Method)methods.get(0),context.getClass());
    return invokeCurrent(component,context);
  }
 else {
    methods=ClassUtils.getSatisfiableMethods(component.getClass(),ClassUtils.getClassTypes(payload),true,true,ignoreMethods);
    if (methods.size() > 1) {
      throw new TooManySatisfiableMethodsException(component.getClass());
    }
    if (methods.size() == 1) {
      if (logger.isDebugEnabled()) {
        logger.debug("Dynamic Entrypoint using method: " + component.getClass().getName() + "."+ ((Method)methods.get(0)).getName()+ "("+ payload.getClass().getName()+ ")");
      }
      addMethod(component,(Method)methods.get(0),payload.getClass());
      return invokeCurrent(component,payload);
    }
 else {
      throw new NoSatisfiableMethodsException(component.getClass(),ClassUtils.getClassTypes(payload));
    }
  }
}
