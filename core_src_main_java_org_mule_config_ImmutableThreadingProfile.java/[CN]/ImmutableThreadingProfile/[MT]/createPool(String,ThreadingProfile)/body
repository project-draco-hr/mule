{
  BlockingQueue buffer;
  if (tp.getMaxBufferSize() > 0 && tp.getMaxThreadsActive() > 1) {
    buffer=new LinkedBlockingDeque(tp.getMaxBufferSize());
  }
 else {
    buffer=new SynchronousQueue();
  }
  ThreadPoolExecutor pool=new ThreadPoolExecutor(Math.max(tp.getMaxThreadsIdle(),tp.getMaxThreadsActive()),tp.getMaxThreadsActive(),tp.getThreadTTL(),TimeUnit.MILLISECONDS,buffer);
  if (tp.getThreadFactory() != null) {
    pool.setThreadFactory(tp.getThreadFactory());
  }
 else {
    if (StringUtils.isNotBlank(name)) {
      pool.setThreadFactory(new NamedThreadFactory(name));
    }
 else {
    }
  }
  if (tp.getRejectedExecutionHandler() != null) {
    pool.setRejectedExecutionHandler(tp.getRejectedExecutionHandler());
  }
 else {
switch (tp.getPoolExhaustedAction()) {
case WHEN_EXHAUSTED_DISCARD_OLDEST:
      pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardOldestPolicy());
    break;
case WHEN_EXHAUSTED_RUN:
  pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
break;
case WHEN_EXHAUSTED_ABORT:
pool.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());
break;
case WHEN_EXHAUSTED_DISCARD:
pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());
break;
default :
pool.setRejectedExecutionHandler(new WaitPolicy(tp.getThreadWaitTimeout(),TimeUnit.MILLISECONDS));
break;
}
}
return pool;
}
