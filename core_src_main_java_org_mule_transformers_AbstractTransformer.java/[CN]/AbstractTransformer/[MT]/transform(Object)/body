{
  String encoding=null;
  UMOMessageAdapter adapter=null;
  if (src instanceof UMOMessageAdapter && !isSourceTypeSupported(UMOMessageAdapter.class,true) && !isSourceTypeSupported(UMOMessage.class,true)) {
    encoding=((UMOMessageAdapter)src).getEncoding();
    adapter=(UMOMessageAdapter)src;
    src=((UMOMessageAdapter)src).getPayload();
  }
  if (encoding == null && endpoint != null) {
    encoding=endpoint.getEncoding();
  }
 else   if (encoding == null) {
    encoding=FileUtils.DEFAULT_ENCODING;
  }
  Class srcCls=src.getClass();
  if (!isSourceTypeSupported(srcCls)) {
    if (ignoreBadInput) {
      logger.debug("Source type is incompatible with this transformer and property 'ignoreBadInput' is set to true, so the transformer chain will continue.");
      return src;
    }
 else {
      throw new TransformerException(CoreMessages.transformOnObjectUnsupportedTypeOfEndpoint(this.getName(),src.getClass(),endpoint),this);
    }
  }
  if (logger.isDebugEnabled()) {
    logger.debug("Applying transformer " + getName() + " ("+ getClass().getName()+ ")");
    logger.debug("Object before transform: " + StringMessageUtils.truncate(StringMessageUtils.toString(src),DEFAULT_TRUNCATE_LENGTH,false));
  }
  Object result=doTransform(src,encoding);
  if (result == null) {
    result=NullPayload.getInstance();
  }
  if (logger.isDebugEnabled()) {
    logger.debug("Object after transform: " + StringMessageUtils.truncate(StringMessageUtils.toString(result),DEFAULT_TRUNCATE_LENGTH,false));
  }
  result=checkReturnClass(result);
  if (adapter != null && isConsumed(srcCls)) {
    adapter.setPayload(result);
  }
  return result;
}
